#+TITLE: C4 Configuration
#+PROPERTY: header-args :mkdirp yes
#+PROPERTY: header-args:emacs-lisp :comments link :tangle yes

* Summary  :noexport:

This configuration is my personal configuration/sandbox that grows as I use my favorite productivity
environment and learn how to do more with it.

C4 prioritizes ease, convenience and performance. A clean, minimal UI is what I love.

This is an Org-driven configuration consisting of this file (=C4.org=), the generated =C4.el= and
the =init.el= that loads it on startup.

If something doesn't add value to my workflow, it simply isn't here.

Custom variables and procedures in this config are always prefixed with =C4=.

* Table of Contents                                                   :TOC@4:
- [[#startup][Startup]]
  - [[#initial-settings][Initial Settings]]
  - [[#theme][Theme]]
    - [[#typography][Typography]]
    - [[#ui][UI]]
  - [[#user-identity][User Identity]]
  - [[#keybindings][Keybindings]]
    - [[#why][Why?]]
    - [[#setup][Setup]]
      - [[#which-key][which-key]]
      - [[#ryo-modal][ryo-modal]]
      - [[#hydra][hydra]]
    - [[#structure][Structure]]
      - [[#command-mode][Command Mode]]
      - [[#actions][Actions]]
      - [[#commands][Commands]]
- [[#performance][Performance]]
  - [[#garbage-collection][Garbage collection]]
- [[#debugging][Debugging]]
  - [[#esup][esup]]
  - [[#elisp-bug-hunter][elisp-bug-hunter]]
  - [[#explain-pause-mode][explain-pause-mode]]
- [[#housekeeping][Housekeeping]]
  - [[#inhibit-lockfiles-and-custom-files][Inhibit lockfiles and custom files]]
  - [[#no-littering][no-littering]]
  - [[#create-parent-directories-automatically][Create parent directories automatically]]
  - [[#whitespace-cleanup-mode][whitespace-cleanup-mode]]
- [[#utilities][Utilities]]
  - [[#enhancements][Enhancements]]
    - [[#mood-line][mood-line]]
    - [[#helpful][helpful]]
    - [[#editorconfig][editorconfig]]
    - [[#eshell][eshell]]
    - [[#crux][crux]]
  - [[#undoredo][Undo/Redo]]
    - [[#undo-fu][undo-fu]]
  - [[#text-manipulation][Text Manipulation]]
    - [[#expand-region][expand-region]]
  - [[#search-and-lookup][Search and Lookup]]
    - [[#selectrum][selectrum]]
    - [[#prescient][prescient]]
    - [[#orderless][orderless]]
    - [[#consult][consult]]
    - [[#embark][embark]]
    - [[#marginalia][marginalia]]
    - [[#ctrlf][ctrlf]]
- [[#projects][Projects]]
  - [[#user-settings][User Settings]]
  - [[#management][Management]]
  - [[#version-control][Version Control]]
    - [[#magit][magit]]
    - [[#forge][forge]]
    - [[#diff-hl][diff-hl]]
- [[#document-modes][Document Modes]]
  - [[#langtool][langtool]]
  - [[#mw-thesaurus][mw-thesaurus]]
  - [[#org][Org]]
    - [[#setup-1][Setup]]
    - [[#breadcrumbs][Breadcrumbs]]
    - [[#agenda][Agenda]]
    - [[#refiling][Refiling]]
    - [[#capture-templates][Capture Templates]]
    - [[#literate-programming][Literate Programming]]
    - [[#interface-addons][Interface Addons]]
      - [[#org-superstar][org-superstar]]
      - [[#visual-fill-column][visual-fill-column]]
      - [[#toc-org][toc-org]]
    - [[#journaling][Journaling]]
    - [[#notes][Notes]]
      - [[#org-roam][org-roam]]
      - [[#deft][deft]]
    - [[#publishing][Publishing]]
      - [[#weblorg][weblorg]]
- [[#programming-modes][Programming Modes]]
  - [[#paths][Paths]]
  - [[#parsing][Parsing]]
  - [[#syntax-highlighting][Syntax Highlighting]]
    - [[#faces][Faces]]
    - [[#rainbow-delimiters][rainbow-delimiters]]
    -  [[#color-identifiers-mode][color-identifiers-mode]]
  - [[#linting][Linting]]
  - [[#formatting][Formatting]]
    - [[#apheleia][apheleia]]
    - [[#smartparens][smartparens]]
    - [[#aggressive-indent-mode][aggressive-indent-mode]]
  - [[#autocompletion][Autocompletion]]
  - [[#language-server-protocol][Language Server Protocol]]
  - [[#snippets][Snippets]]
  - [[#language-support][Language Support]]
    - [[#lisp-family][Lisp Family]]
      - [[#emacs-lisp][Emacs Lisp]]
      - [[#common-lisp][Common Lisp]]
      - [[#racket][Racket]]
      - [[#guile][Guile]]
    - [[#web-dev][Web Dev]]
    - [[#javascripttypescript][JavaScript/TypeScript]]
      - [[#setup-2][Setup]]
    - [[#raku][Raku]]
  - [[#rainbow-mode][rainbow-mode]]
- [[#guix][Guix]]

* Startup
** Initial Settings

I start working out the look and feel of my workspace as well as establish some global settings.

#+BEGIN_SRC emacs-lisp
(setq-default cursor-type 'bar) ; default cursor as bar
(setq-default frame-title-format '("%b")) ; window title is the buffer name

(setq linum-format "%4d ") ; line number format
(column-number-mode 1) ; set column number display
(show-paren-mode 1) ; show closing parens by default

(menu-bar-mode -1) ; disable the menubar
(scroll-bar-mode -1) ; disable the scroll bar
(set-fringe-mode 8) ; Set fringe
(tool-bar-mode -1) ; disable toolbar
(tooltip-mode -1) ; disable tooltips

(setq inhibit-startup-message t) ; inhibit startup message
(setq initial-scratch-message "") ; no scratch message
(setq initial-major-mode 'text-mode) ; set scratch to generic text mode
(setq visible-bell t)             ; enable visual bell
(global-auto-revert-mode t) ; autosave buffer on file change
(delete-selection-mode 1) ; Selected text will be overwritten on typing
(fset 'yes-or-no-p 'y-or-n-p) ; convert "yes" or "no" confirms to "y" and "n"

;; Show line numbers in programming modes
(add-hook 'prog-mode-hook
          (if (and (fboundp 'display-line-numbers-mode) (display-graphic-p))
              #'display-line-numbers-mode
            #'linum-mode))

;; Disable for document and terminal modes
(dolist (mode '(
                org-mode-hook
                term-mode-hook
                shell-mode-hook
                treemacs-mode-hook
                vterm-mode
                eshell-mode-hook))
  (add-hook mode (lambda () (display-line-numbers-mode 0))))

;; Give buffers unique names
(setq uniquify-buffer-name-style 'post-forward-angle-brackets)

;; Make some icons available
(use-package all-the-icons)

#+END_SRC

** Theme

For my theme, I extend my wpgtk theme into Emacs with ewal.

#+BEGIN_SRC emacs-lisp
;; Setup ewal
(use-package ewal
  :init
  (setq ewal-use-built-in-always-p nil)
  (setq ewal-use-built-in-on-failure-p t)
  (setq ewal-built-in-palette "sexy-material")
  (setq ewal-json-file "~/.cache/wal/colors.json")
  :config (ewal-load-colors))

;; Load in themes
(use-package ewal-doom-themes
  :config (load-theme 'ewal-doom-vibrant t))

#+END_SRC

*** Typography

The typography of C4 is entirely based on Input Sans using varied weights, styles and sizes.

#+BEGIN_SRC emacs-lisp
;;; Use Input Sans for all the things

(defun C4/round-height (height)
  "Rounds the input HEIGHT to the nearest ten."
  (let* ((~height~ (truncate height))
   (*height* (round ~height~ 10))) (* *height* 10)))

;; Font settings
(defvar C4/font "Input Sans")
(defvar C4/font-mono "Input Mono")
(defvar C4/font-size 110)
(defvar C4/font-ratio 1.125)

(defvar C4/font-size-doc
  (C4/round-height (* C4/font-size C4/font-ratio C4/font-ratio)))

;; Default font
(set-face-attribute 'default nil
        :family C4/font :height C4/font-size :foreground (ewal-load-color 'white))

;; Code font
(set-face-attribute 'fixed-pitch nil
        :family C4/font :width 'condensed :height C4/font-size :foreground (ewal-load-color 'white))

;; Enlarge for Org-mode
(set-face-attribute 'variable-pitch nil :family C4/font :height C4/font-size-doc)

;; Set a line number style
(set-face-attribute 'line-number nil  :family C4/font-mono :height C4/font-size)
(set-face-attribute 'line-number-current-line nil
        :inherit 'line-number :weight 'semi-bold :foreground (ewal-load-color 'white))
#+END_SRC

*** UI

I also make some adjustments to the UI faces. Mainly to clean it up.

#+BEGIN_SRC emacs-lisp

;;; Disable the fringe background
(set-face-attribute 'fringe nil :background nil)

;;; Eliminate all mode line decorations
(set-face-attribute 'mode-line nil :box nil)
(set-face-attribute 'mode-line-inactive nil :box nil)

#+END_SRC

** User Identity

#+BEGIN_SRC emacs-lisp

;;; Set full name and email address
(setq user-full-name "Chatman R. Jr")
(setq user-mail-address "crjr.code@protonmail.com")

#+END_SRC

** Keybindings

This configuration sets up keybindings with a non-evil modal setup bound either to a global modal
state or major/minor modes.

*** Why?

Emacs is slowly pushing me to think less like a Vimmer, and because of this, evil-mode feels limiting.

I'm beginning to understand that major and minor modes *are already contextual* and it makes the
most sense to define keybindings in Emacs according to which modes are /active/ in a buffer rather
than by toggling arbitrary states.

That said, I do like the modal editing workflow. It's better for my health than many of the default
Emacs keybinding contortions.

*** Setup
**** which-key

which-key provides an interface for discovering keybindings in Emacs. Both built-in and user
defined. It's absolutely essential since I'm building an evolving custom modal setup and can't keep
it all in my head.

#+BEGIN_SRC emacs-lisp

;;; Setup which-key for keybinding discoverability
(use-package which-key
  :custom
  (which-key-idle-delay 1.5)
  (which-key-enable-extended-define-key t)
  (which-key-sort-order 'which-key-prefix-then-key-order)
  :config
  (which-key-mode))

#+END_SRC

**** ryo-modal

RYO modal allows me to create modal keybindings of my own design.

#+BEGIN_SRC emacs-lisp

;;; Command mode initialization
(use-package ryo-modal
  :commands (ryo-modal-mode)
  :bind
  ("C-SPC" . ryo-modal-mode)
  ("<menu>" . ryo-modal-mode)
  :hook
  (text-mode . ryo-modal-mode)
  (prog-mode . ryo-modal-mode)
  :config
  ;; which-key integration
  (push '((nil . "ryo:.*:") . (nil . "")) which-key-replacement-alist)

  ;; Set activated cursor color
  (setq ryo-modal-cursor-color (ewal-load-color 'red))

  ;; C-i needs to be its own keybinding
  (keyboard-translate ?\C-i ?\M-i))

#+END_SRC

**** hydra

This package allows me to create keybinding sandboxes for more complex operations. Kind of like a
mode within a mode.

#+BEGIN_SRC emacs-lisp

;;; Setup transient mode-ish interfaces
(use-package hydra)

#+END_SRC

*** Structure
**** Command Mode

Command Mode is defined by =ryo= in the modeline and is the global "normal" state from where I can
issue actions or mnemonic commands. With C4, Emacs loads in this state.

When Command mode is disabled, Emacs works as usual.

Built-in commands are bound in the following sections, while package-supplied commands are bound
alongside the installation and configuration of those packages.

**** Actions

Actions are low level commands. These include moving around the buffer, toggling command mode,
undo/redo motions and more.

***** Exiting Command Mode

Command Mode has a few simple escape hatches for when I'm ready to enter some text:

+ =SPC SPC= and =q= to insert at point
+ =<return>= to insert a new line below point
+ =<C-return>= to insert a new line above point

#+BEGIN_SRC emacs-lisp

;;; Actions: insertion
(ryo-modal-keys
 ("q" ryo-modal-mode :name "insert at point")
 ("SPC SPC" ryo-modal-mode :name "insert at point"))

#+END_SRC

***** Modifiers

I set two kinds of action modifiers: numeric and procedural.

+ Numeric action modifiers: repeat an action =n= times (ex: =4 i= will move the point 4 lines up)
+ Procedural action modifier: repeat last action explicitly (ex: =4 i .= will move the point 8 lines
  up)

#+BEGIN_QUOTE
Note: giving a numeric modifier to the procedural modifier will give the repeated action a /new/
numeric modifier. This is the expected Emacs behavior for =digit-argument=.
#+END_QUOTE

#+BEGIN_SRC emacs-lisp

;;; Action modifiers
(ryo-modal-keys
 ;; procedural modifier
 ("." ryo-modal-repeat)
 ;; numeric modifiers
 ("-" "M--" :norepeat t)
 ("0" "M-0" :norepeat t)
 ("1" "M-1" :norepeat t)
 ("2" "M-2" :norepeat t)
 ("3" "M-3" :norepeat t)
 ("4" "M-4" :norepeat t)
 ("5" "M-5" :norepeat t)
 ("6" "M-6" :norepeat t)
 ("7" "M-7" :norepeat t)
 ("8" "M-8" :norepeat t)
 ("9" "M-9" :norepeat t))

#+END_SRC

***** Movement

These actions help me get around the buffer quickly. They're somewhat modeled after Xah Fly Keys but
use modifiers to change the scope of the action. So I can use the same four keys to hop around.

#+BEGIN_SRC emacs-lisp

;;; Actions: movement
(ryo-modal-keys
 ("i" previous-logical-line :name "previous line")
 ("I" scroll-down-command :name "scroll up the buffer")
 ("M-i" beginning-of-buffer :name "jump point to beginning of buffer")
 ("k" next-logical-line :name "next line")
 ("K" scroll-up-command :name "scroll down the buffer")
 ("C-k" end-of-buffer :name "jump point to end of buffer")
 ("j" backward-char :name "previous char")
 ("J" backward-word :name "jump point to previous word")
 ("C-j" beginning-of-line-text :name "jump point to beginning text of line")
 ("M-j" beginning-of-line :name "jump point to beginning of line")
 ("l" forward-char :name "next char")
 ("L" forward-word :name "jump point to next word")
 ("C-l" end-of-line :name "jump point to end of line")
 ("M-l" end-of-line :name "jump point to end of line"))

#+END_SRC

***** Marking/selecting

These actions are mapped to marking regions and text selection.

#+BEGIN_SRC emacs-lisp

(defun C4/mark-line ()
  "Mark the entire line"
  (interactive)
  (end-of-line)
  (set-mark-command nil)
  (beginning-of-line))

;;; Actions: marking/selecting text
(ryo-modal-keys
 ("m" set-mark-command :name "set a mark at point")
 ("M"
  (("w" mark-word :name "mark word")
   ("l" C4/mark-line :name "mark current line")
   ("p" mark-paragraph :name "mark paragraph")) :name "semantic mark"))

#+END_SRC

***** Killing/cutting

Now, some actions for killing and cutting text.

#+BEGIN_SRC emacs-lisp

;;; Actions: killing/cutting text
(ryo-modal-keys
 ("x" kill-region :wk "cut selection")
 ("X" clipboard-kill-region :wk "cut selection (system)"))

#+END_SRC

***** Copy/paste

Some actions for copying and pasting text.

#+BEGIN_SRC emacs-lisp

;;; Actions: copy/paste
(ryo-modal-keys
 ("c" kill-ring-save :name "copy selection")
 ("C" clipboard-kill-ring-save :name "copy selection (system)")
 ("v" yank :name "paste")
 ("V" clipboard-yank :name "paste (system)"))

#+END_SRC

***** Deletion

Finally, some actions for deleting text. This is the final manipulation. Deleted text will
/not/ be saved to the kill ring or anywhere else. It's gone.

Also, following the conventions of other actions, =D= is a modifier that opens other actions
for deletion. In this case, it begins deletion chords.

#+BEGIN_SRC emacs-lisp

;;; Actions: deleting text
(ryo-modal-keys
 ("d" delete-char :wk "delete char after point")
 ("D"
  (("d" backward-delete-char :name "delete char before point")
   ("r" delete-region :name "delete-region"))))

#+END_SRC

**** Commands

The C4 command keybindings all share =SPC= as a prefix.

Some of the commands will trigger a transient state with its own local keybindings.

Keybindings mapped to built-in commands are documented in this section.

Beyond that, package provided commands are defined alongside their packages. Some keybindings, like
those of a major programming mode, define their own major prefixes.

C4 uses command prefixes to group bindings to their area of influence.

***** Modifiers

Similar to actions, each command optionally takes modifiers.

#+BEGIN_SRC emacs-lisp

;;; Command modifiers
(ryo-modal-keys
 ("SPC u" universal-argument :name "command modifier"))

#+END_SRC

***** Buffer (=b=)

This prefix wraps all commands that affect buffers Lowercase bindings affect only the current
buffer, uppercase bindings affect /all/ active buffers or modify a buffer-local command.

#+BEGIN_SRC emacs-lisp

;;; Domain: buffers
(ryo-modal-keys
 ;; state
 ("SPC b"
  (("d" kill-this-buffer :name "kill")
   ("D" kill-some-buffers :name "kill multiple")
   ("k" kill-this-buffer :name "kill")
   ("K" kill-some-buffers :name "kill multiple")
   ("w" save-buffer :name "save")
   ("W" save-some-buffers :name "save modified")
   ;; narrowing
   ("n"
    (("n" widen :name "reset")
     ("d" narrow-to-defun :name "to defun")
     ("p" narrow-to-page :name "to page")
     ("r" narrow-to-region :name "to region")) :name "narrow")) :name "buffer"))

#+END_SRC

***** Config (=c=)

This prefix wraps all commands that make it easier to work with my configuration itself. This
includes quickly opening and reloading my config.

In addition, I define bindings that make it easier to evaluate expressions, defuns and regions in
place as I try out new settings.

#+BEGIN_SRC emacs-lisp

(defconst C4/config (expand-file-name "C4.org" user-emacs-directory)
  "The central C4 config file.")

(defun C4/open-config ()
  "Open C4 configuration Org file."
  (interactive)
  (find-file C4/config))

(defun C4/reload-config ()
  "Reload C4 configuration."
  (interactive)
  (load-file user-init-file))

;;; Domain: config
(ryo-modal-keys
 ;; manage
 ("SPC c"
  (("c" C4/open-config :name "open")
   ("r" C4/reload-config :name "reload")
   ;; eval
   ("e"
    (("e" eval-last-sexp :name "expression")
     ("d" eval-defun :name "defun")
     ("r" eval-region :name "region")
     ("b" eval-buffer :name "buffer")) :name "eval")) :name "C4 config"))

#+END_SRC

***** File (=f=)

This prefix wraps all commands that affect the filesystem. It includes finding and renaming files.

#+BEGIN_SRC emacs-lisp

;;; Domain: file
(ryo-modal-keys
 ("SPC f"
  (("f" find-file :name "find")
   ("F" find-file-other-window :name "other window")
   ("d" dired :name "directory")) :name "file"))

#+END_SRC

***** Help (=h=)

This domain wraps all commands that query Emacs for help about its functionality. It also allows me
to quickly bring up the Emacs manual for browsing.

#+BEGIN_SRC emacs-lisp

;;; Domain: help
(ryo-modal-keys
 ("SPC h"
  (("F" describe-face :name "face")
   ("m" info-emacs-manual :name "Emacs manual")) :name "help"))

#+END_SRC

***** Session (=q=)

This domain wraps commands that affect Emacs sessions

#+BEGIN_SRC emacs-lisp

;;; Domain: session
(ryo-modal-keys
 ("SPC q"
  (("q" save-buffers-kill-emacs :name "quit")
   ("Q" kill-emacs :name "really quit")) :name "session"))

#+END_SRC

***** Toggle (=t=)

This domain wraps interface toggles and micro-adjustments.

#+BEGIN_SRC emacs-lisp

(defhydra C4/text-scale (:timeout 15)
  "Interactively scale text"
  ("+" text-scale-increase "inc")
  ("-" text-scale-decrease "dec")
  ("RET" nil "exit" :exit t))

;;; Domain: toggle
(ryo-modal-keys
 ("SPC t"
  (("s" C4/text-scale/body :name "text scaling")) :name "toggle"))

#+END_SRC

***** Window (=w=)

This domain wraps all commands that affect windows.

Windows in Emacs can be split, moved, and closed when not needed.

This marks one of the biggest differences between Vim and Emacs: windows are /views/. Buffers in
Emacs are detached from windows and are not killed when a window closes. They persist in the
background until called into another window.

#+BEGIN_SRC emacs-lisp

(defhydra C4/window-commander (:timeout 45)
  "Interactive window navigation"
  ("SPC" other-window "cycle")
  ("c" delete-window "close")
  ("C" delete-other-windows "fill frame")
  ("i" windmove-up "jump up")
  ("I" windmove-swap-states-up "swap up")
  ("M-i" windmove-delete-up "close above")
  ("k" windmove-down "jump down")
  ("K" windmove-swap-states-down "swap down")
  ("C-k" windmove-delete-down "close below")
  ("j" windmove-left "jump left")
  ("J" windmove-swap-states-left "swap left")
  ("C-j" windmove-delete-left "close left")
  ("l" windmove-right "jump right")
  ("L" windmove-swap-states-right "swap right")
  ("C-l" windmove-delete-right "close right")
  ("RET" nil "exit" :exit t))

;;; Domain: window
(ryo-modal-keys
 ("SPC w"
  (("w" other-window :name "switch")
   ("c" delete-window :name "close")
   ("C" delete-other-windows :name "close other")
   ("n"
    (("n" C4/window-commander/body :name "state: window commander")
     ("i" windmove-up :name "jump up")
     ("I" windmove-swap-states-up :name "swap up")
     ("M-i" windmove-delete-up :name "close above")
     ("k" windmove-down :name "jump down")
     ("K" windmove-swap-states-down :name "swap down")
     ("C-k" windmove-delete-down :name "close below")
     ("j" windmove-left :name "jump left")
     ("J" windmove-swap-states-left :name "swap left")
     ("C-j" windmove-delete-left :name "close left")
     ("l" windmove-right :name "jump right")
     ("L" windmove-swap-states-right :name "swap right")
     ("C-l" windmove-delete-right :name "close fright")) :name "navigator")
   ("s"
    (("s" split-window-below :name "horizontal")
     ("S" split-window-right :name "vertical")) :name "split"))
  :name "window"))

#+END_SRC

* Performance
** Garbage collection

The first optimization involves increasing the Emacs garbage collection threshold to =100MB= on
startup. This gives a slight boost in initialization. After Emacs starts up, we use a hook to reduce
the threshold back to its approximate initial state.

#+BEGIN_SRC emacs-lisp

;;; Raise the garbage collection threshold high as emacs starts
(setq gc-cons-threshold 100000000)
(setq read-process-output-max (* 1024 1024))

;;; Drop it down once loaded
(add-hook 'after-init-hook #'(lambda () (setq gc-cons-threshold 1000000)))

#+END_SRC

* Debugging

When things break, I need ways of figuring out the problem. And without measurements, I can't make
improvements.

** esup

ESUP (Emacs Start Up Profiler) is an invaluable package for benchmarking how quickly Emacs loads. My
aim: make C4 feature complete for my needs while also loading fast enough for my slightly older laptop.

#+BEGIN_SRC emacs-lisp

;;; Benchmark Emacs startup to debug performance
(use-package esup
  :ryo
  ("SPC c d"
   (("d" esup :name "startup")) :name "debug"))

#+END_SRC

** elisp-bug-hunter

elisp-bug-hunter is a package that allows me to track down and eliminate bugs in C4 that might be
hiding in the tall grass.

#+BEGIN_SRC emacs-lisp

;;; Debug init file errors
(use-package bug-hunter
  :ryo
  ("SPC c d"
   (("e" bug-hunter-init-file :name "errors"))))

#+END_SRC

** explain-pause-mode

explain-pause-mode is like =top= (more accurately =htop=) for Emacs. It allows you see all recently
run operations and discover which ones are making Emacs lag. This ensures tight performance carries
over for more than just startup times.

#+BEGIN_SRC emacs-lisp

;;; Check running processes in Emacs for slowdowns
(use-package explain-pause-mode
  :ryo
  ("SPC c d"
   (("p" explain-pause-top :name "processes")))
  :config
  (explain-pause-mode))

#+END_SRC

* Housekeeping

Now I want to do some decluttering. Emacs has a way of operating with files that can leave a lot of
crap behind in my filesystem, so I needed to do a little cleanup and ordering of where and if it
generates temporary files and directories.

** Inhibit lockfiles and custom files

My experience with lockfiles is that they add a lot of noise to my directories and projects, so I'm
just going to disable them entirely. The same goes for custom files, because I prefer to do all of
my customizations with Emacs Lisp.

#+BEGIN_SRC emacs-lisp

;;; Lockfiles do more harm than good
(setq create-lockfiles nil)

;;; Custom files just add clutter
(setq custom-file null-device)

#+END_SRC

** no-littering

no-littering is a great package that ensures files and directories generated by Emacs or its
packages are allocated to their proper places. The killer feature is how it allows you to set a
central directory for all autosaved files.

#+BEGIN_SRC emacs-lisp

;;; Put temporary and data files in proper locations
(use-package no-littering
  :custom
  (auto-save-file-name-transforms
   `((".*" ,(no-littering-expand-var-file-name "auto-save/") t))))

#+END_SRC

** Create parent directories automatically

One great thing about Emacs is that I can manage my ideas and work as they come. I streamline this
by telling Emacs to automatically create directories that don't exist for new files. This allows me
to build the file structure for my projects on the fly.

#+BEGIN_SRC emacs-lisp

;;; Create parent dirs when opening new files
(add-to-list 'find-file-not-found-functions #'C4/create-parent)

(defun C4/create-parent ()
  "Ensures that the parent dirs are created for a nonexistent file."
  (let ((parent-directory (file-name-directory buffer-file-name)))
    (when (and (not (file-exists-p parent-directory))
               (y-or-n-p (format
                          "Directory `%s' does not exist! Create it?"
                          parent-directory)))
      (make-directory parent-directory t))))

#+END_SRC

** whitespace-cleanup-mode

whitespace-cleanup-mode is a package that intelligently checks files for errant whitespace and
cleans it up before saving. By default, C4 enables this behavior globally.

Some modes can be set to disable this behavior as exceptions.

#+BEGIN_SRC emacs-lisp

;;; Clean up whitespace in all major modes on save
(use-package whitespace-cleanup-mode
  :config
  (global-whitespace-cleanup-mode t))

#+END_SRC

* Utilities
** Enhancements

Now I'll add some improvements to my baseline experience.

*** mood-line

mood-line is a minimal, zero-dependency mode line that replicates the clean look and functionality
of doom-modeline.

#+BEGIN_SRC emacs-lisp

;;; Lightweight mode line goodness
(use-package mood-line :config (mood-line-mode))

#+END_SRC

*** helpful

Helpful provides better help documentation for the many description functions in Emacs. It also
includes its own extremely /helpful/ utilities like checking a symbol at its point.

#+BEGIN_SRC emacs-lisp

;;; Help documentation enhancements
(use-package helpful
  :ryo
  ("SPC h"
   (("h" helpful-at-point :name "symbol at point")
    ("f" helpful-function :name "function")
    ("c" helpful-command :name "command")
    ("C" helpful-callable :name "callable")
    ("v" helpful-variable :name "variable")
    ("k" helpful-key :name "keybinding"))))

#+END_SRC

*** editorconfig

Editorconfig is a utility that normalizes basic syntax considerations for file types across editors. It ensures
you only have to maintain one file to have a solid base for editing plain text and programming source
languages.

First, install the plugin for Emacs.

#+BEGIN_SRC emacs-lisp

;;; Universal editor settings
(use-package editorconfig
  :config
  (editorconfig-mode 1))

#+END_SRC

Then set some basic options. These are the ones I use:

#+BEGIN_SRC editorconfig-conf :tangle "~/.editorconfig"
# Environment-wide editorconfig
root = true

[*]
charset = utf-8
indent_style = space
indent_size = 2
max_line_length = 80
insert_final_newline = true
trim_trailing_whitespace = true

[*.md]
trim_trailing_whitespace = false

[*.{cmd,bat}]
end_of_line = crlf

[*.sh]
end_of_line = lf

# Documents
[*.{md,markdown,org}]
max_line_length = 100
#+END_SRC

*** eshell

Eshell is underappreciated and powerful in its own right. The built-in =term= covers most of my use
cases for when I do need a full terminal environment. So I replaced vterm with eshell enhancements
and then added shell-pop for easy access.

#+BEGIN_SRC emacs-lisp
;; Enhanced eshell
(use-package eshell-prompt-extras
  :custom
  (eshell-highlight-prompt nil)
  (eshell-prompt-function 'epe-theme-lambda))

;; Easy shell access
(use-package shell-pop
  :ryo
  ("SPC '" shell-pop :name "pop a terminal")
  ("SPC \"" term :name "open terminal")
  :custom
  (shell-pop-window-size 30)
  (shell-pop-shell-type (quote ("eshell" "*Eshell*" (lambda nil (eshell))))))
#+END_SRC

*** crux

This configuration includes the crux package. It's way too useful not to use. Especially since I
opted out of Vim emulation.

#+BEGIN_SRC emacs-lisp

;;; Utilities for useful Emacs functions
(use-package crux
  :ryo
  ("<return>" crux-smart-open-line :name "insert new line" :exit t)
  ("<C-return>" crux-smart-open-line-above :name "insert new line above" :exit t)
  ("SPC f"
   (("x" crux-create-scratch-buffer :name "scratch")
    ("r" crux-rename-file-and-buffer :name "rename")
    ("D" crux-delete-file-and-buffer :name "delete")))
  :hook
  (find-file . crux-reopen-as-root-mode))

#+END_SRC

Crux supplies the commands for insertion actions that open a new line.

** Undo/Redo

This section documents necessary packages to improve how Emacs handles undo and redo actions.

*** undo-fu

Undo-fu is a much lighter package in comparison with undo-tree. It makes undo actions much more
sensible and provides an essential redo function. Pairing it with undo-fu-session allows me to keep
a history of editing actions performed on a file through its whole existence.

#+BEGIN_SRC emacs-lisp

;;; Better undo/redo
(use-package undo-fu
  :ryo
  ("z" undo-fu-only-undo :name "undo last edit")
  ("Z" undo-fu-only-redo :name "redo last edit")
  ("C-z" undo-fu-only-redo-all :name "restore edits to most recent state"))

;; Undo persistence
(use-package undo-fu-session
  :hook
  (prog-mode . undo-fu-session-mode)
  (text-mode . undo-fu-session-mode)
  (org-mode . undo-fu-session-mode))

#+END_SRC

** Text Manipulation

It's time to setup some great packages that make text manipulation in Emacs less painful.

*** expand-region

This is a package that expands marked regions by semantic units.

#+BEGIN_SRC emacs-lisp

;;; Expand region selections by semantic units
(use-package expand-region
  :ryo
  ("M"
   (("m" er/expand-region :name "cycle targets")
    ("s" er/mark-sentence :name "mark sentence")
    ("[" er/mark-inside-pairs :name "mark between delimiters")
    ("{" er/mark-outside-pairs :name "mark around delimiters")
    ("'" er/mark-inside-quotes :name "mark inside quotes")
    ("\"" er/mark-outside-quotes :name "mark around quotes"))))

#+END_SRC

** Search and Lookup

This section documents a special category of enhancements for finding and jumping to things in
Emacs. Popular packages to set this up include the ivy and helm ecosystems, but I decided to look at
some of the lighter, newer packages that augment built-in functionality instead.

*** selectrum

Selectrum is an Ido, Icomplete drop in enhancement. It provides basic, clean minibuffer completion
on its own, but its powers are boosted by the remaining packages.

#+BEGIN_SRC emacs-lisp

;;; Better minibuffer completion
(use-package selectrum
  :config
  (selectrum-mode 1))

#+END_SRC

*** prescient

Prescient builds a store of my most used commands and queries and places them first. So I
have quick access to candidates for keybindings.

#+BEGIN_SRC emacs-lisp

;;; Remember frequently used commands and queries
(use-package selectrum-prescient
  :after selectrum
  :config
  (selectrum-prescient-mode 1)
  (prescient-persist-mode 1))

#+END_SRC

*** orderless

Orderless allows you to enter your minibuffer queries as partial characters or strings. This means I
don't have to know the whole, proper name of something to find it in Emacs.

#+BEGIN_SRC emacs-lisp

;;; Partial completion queries support
(use-package orderless
  :init
  (icomplete-mode)
  :custom
  (completion-styles '(orderless)))

#+END_SRC

*** consult

#+BEGIN_SRC emacs-lisp

;;; Better search utilities
(use-package consult
  :ryo
  ("SPC ." consult-complex-command :name "query command history")
  ("C-v" consult-yank :name "paste from registry")
  ("SPC b"
   (("b" consult-buffer :name "switch")
    ("B" consult-buffer-other-window :name "other window")))
  ("SPC h" (("a" consult-apropos :name "apropos")))
  ("SPC p" (("s" consult-ripgrep :name "search")) :name "project")
  :init
  (defun find-fd (&optional dir initial)
    (interactive "P")
    (let ((consult-find-command "fd --color=never --full-path ARG OPTS"))
      (consult-find dir initial)))
  (advice-add #'register-preview :override #'consult-register-window)
  :custom
  (register-preview-delay 0)
  (register-preview-function #'consult-register-window)
  (consult-narrow-key "<"))

#+END_SRC

*** embark

Embark provides an interface for performing actions in minibuffers. I'm not doing much with it yet,
but it's still there when I do need it.

#+BEGIN_SRC emacs-lisp

;;; An interface for minibuffer actions
(use-package embark-consult
  :after (embark consult)
  :demand t
  :hook
  (embark-collect-mode . embark-consult-preview-minor-mode))

#+END_SRC

*** marginalia

Marginalia is a consult enhancement package that includes useful supplemental information in lookup
operations. For example: showing the docstring for interactive commands or the current styling of a face.

#+BEGIN_SRC emacs-lisp

;;; Adds annotations to minibuffer interfaces
(use-package marginalia
  :after selectrum
  :init
  (advice-add #'marginalia-cycle :after
              (lambda () (when (bound-and-true-p selectrum-mode)
                           (selectrum-exhibit))))
  (setq marginalia-annotators
        '(marginalia-annotators-heavy marginalia-annotators-light))
  :config
  (marginalia-mode 1))

#+END_SRC

*** ctrlf

I love this package.

CTRLF allows me to find anything—and I mean anything in a buffer. Most describe it as a drop-in
Swiper replacement, but it's much more than that.

For one, I like how it doesn't populate the query results with false positives. I also like how it
doesn't assume I need to see /all/ the query results right away. I can jump through them and keep
narrowing the search until there's only one result: the correct one.

#+BEGIN_SRC emacs-lisp

;;; Incremental search interface similar to web browsers
(use-package ctrlf
  :ryo
  ("SPC b s"
   (("s" ctrlf-forward-literal :name "forward literal")
    ("S" ctrlf-backward-literal :name "backward literal")
    ("f" ctrlf-forward-fuzzy :name "forward fuzzy")
    ("F" ctrlf-backward-fuzzy :name "backward fuzzy")
    ("r" ctrlf-forward-regexp :name "forward regexp")
    ("R" ctrlf-backward-regexp :name "backward regexp")) :name "isearch")
  :hook
  (text-mode . ctrlf-mode)
  (prog-mode . ctrlf-mode)
  (org-mode . ctrlf-mode))

#+END_SRC

This package provides the buffer-local keybindings for incremental search.

* Projects
** User Settings

Now, I need to set up Emacs for my preferred project flow. To make configuration a little easier,
I'm going to define some variables for my root project path and my GitHub username.

#+BEGIN_SRC emacs-lisp

;;; Set variables for my root project directory and GitHub username
(setq C4/project-root '("~/Code"))
(setq C4/gh-user "cr-jr")

#+END_SRC

** Management

Project management in my configuration is handled by projectile, the best-in-class package for efficently
working with projects under version control.

#+BEGIN_SRC emacs-lisp

;;; Project management
(use-package projectile
  :ryo
  ("SPC p"
   (("p" projectile-switch-project :name "switch")
    ("'" projectile-run-vterm :name "open terminal")
    ("f" projectile-find-file :name "find file")))
  :hook
  (ryo-modal-mode . projectile-mode)
  :custom
  (projectile-project-search-path C4/project-root)
  (projectile-sort-order 'recently-active)
  (projectile-switch-project-action #'projectile-dired)
  :bind-keymap
  ("C-c p" . projectile-command-map))

#+END_SRC

** Version Control

My workflow is Git and GitHub driven so the packages configured here reflect that.

*** magit

Magit is probably the last Git repo manager I'll ever need. That's how good it is.

#+BEGIN_SRC emacs-lisp

;;; Magical Git management
(use-package magit
  :ryo
  ("SPC g"
   (("g" magit :name "status")
    ("c" magit-commit :name "commit")
    ("d" magit-diff :name "diff")
    ("i" magit-init :name "init")
    ("p" magit-push :name "push")
    ("P" magit-pull :name "pull")
    ("r" magit-remote :name "remote")
    ("s" magit-stage :name "stage")
    ("S" magit-stage-file :name "stage current file")) :name "git")
  :commands (magit magit-status)
  :custom
  (magit-completing-read-function #'selectrum-completing-read)
  (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1))

#+END_SRC

*** forge

Forge is a magit extension that integrates Git forges (GitHub, Gitlab) into the magit interface and flow.

It allows complete remote repo management from right in Emacs. Including *handling issues and pull requests*.

#+BEGIN_QUOTE
Be aware that none of this configuration will work unless forge can hook into a personal access token from the
GitHub account defined by  =C4/gh-user=.
#+END_QUOTE

#+BEGIN_SRC emacs-lisp

;;; A Magit extension to manage Git forges (GitHub, GitLab) from Magit
(use-package forge
  :after magit
  :ryo
  ("SPC g f"
   (("f" forge-pull :name "pull")
    ("F" forge-fork :name "fork repo")
    ("i" forge-list-issues :name "issues")
    ("I" forge-create-issue :name "create issue")) :name "forge")
  :custom
  (auth-sources '("~/.authinfo"))
  :config
  (ghub-request "GET" "/user" nil
                :forge 'github
                :host "api.github.com"
                :username C4/gh-user
                :auth 'forge))

#+END_SRC

*** diff-hl

The final ingredient is diff-hl: a package that shows whether a file under version control has additions,
modifications or deletions since the last commit.

#+BEGIN_SRC emacs-lisp

  ;;; Show how files have changed between commits
  (use-package diff-hl
    :after magit
    :hook
    (magit-pre-refresh . diff-hl-magit-pre-refresh)
    (magit-post-refresh . diff-hl-magit-post-refresh)
    :config
    (global-diff-hl-mode 1))

#+END_SRC

* Document Modes

This section includes all the settings and packages I use for everyday writing and publishing.

** langtool

My configuration uses =langtool= to help me tighten my prose and say what I mean.

#+BEGIN_SRC emacs-lisp

;;; Writing improvement tools

;; Setup langtool
(use-package langtool
  :commands (langtool-check)
  :ryo
  (:mode 'text-mode)
  ("SPC d"
   (("d" langtool-check :name "check")
    ("D" langtool-check-done :name "done")
    ("i" langtool-show-message-at-point :name "info")
    ("c" langtool-correct-buffer :name "correct")) :name "writing assistant")
  :init
  (setq langtool-language-tool-server-jar "~/Source/LanguageTool-5.2-stable/languagetool-server.jar"))

#+END_SRC

** mw-thesaurus

I also use =mw-thesaurus= and the Merriam-Webster dictionary API to help me discover better ways to say it.

#+BEGIN_SRC emacs-lisp

;; Setup mw-thesaurus
(use-package mw-thesaurus
  :ryo
  (:mode 'text-mode)
  ("SPC d w" mw-thesaurus-lookup-dwim :name "word lookup")
  :custom
  (mw-thesaurus--api-key "629ccc6a-d13c-47dc-a3bd-4f807b3b90a6"))

#+END_SRC

** Org

My main document mode is Org Mode. I use it for nearly everything, so it's extensively configured and includes
quite a few addons.

*** Setup

To keep things clean in this section, I use the =noweb= property of Org-babel so I can define more complex
settings in their own section.

A lot of this setup was lifted directly from Emacs from Scratch and I'll customize it over time as my Org Mode
flow becomes more personal.

#+BEGIN_SRC emacs-lisp :noweb yes

(defhydra org-trek (:timeout 30)
  "A transient mode to logically browse an Org file"
  ("h" org-forward-heading-same-level "jump to next heading (same level)")
  ("H" org-backward-heading-same-level "jump to prev heading (same level)")
  ("s" org-babel-next-src-block "jump to next src block")
  ("S" org-babel-previous-src-block "jump to prev src block")
  ("v" org-next-visible-heading "jump to next heading")
  ("V" org-previous-visible-heading "jump to prev heading")
  ("RET" nil "exit state: org-trek" :exit t))

(defhydra org-reorg (:timeout 30)
  "A transient mode to rearrange things"
  ("i" org-move-item-up "move item up")
  ("I" org-move-subtree-up "move subtree up")
  ("k" org-move-item-down "move item down")
  ("K" org-move-subtree-down "move subtree down")
  ("RET" nil "exit state: org-reorg" :exit t))

<<org-breadcrumbs>>
<<org-refiling>>

;;; Org setup
(use-package org
  :ryo
  ("SPC o" nil :name "org")
  (:mode 'org-mode)
  ("M b" org-babel-mark-block :name "block")
  ("M e" org-mark-element :name "element")
  ("SPC o a"
   (("a" org-agenda-list :name "weekly")
    ("f" org-agenda :name "full")
    ("t" org-set-tags-command :name "tags")) :name "agenda")
  ("SPC o b"
   (("b" org-insert-link :name "link")
    ("c" org-capture :name "capture")
    ("r" my/org-refile-in-file :name "refile")
    ("R" org-refile :name "to agenda")
    ("n"
     (("n" org-toggle-narrow-to-subtree :name "subtree")
      ("b" org-narrow-to-block :name "block")
      ("e" org-narrow-to-element :name "element")) :name "narrow")
    ("m" org-reorg/body :name "state: org-reorg")
    ("s" org-trek/body :name "state: org-trek")) :name "buffer")
  ("SPC o d"
   (("d" org-deadline :name "deadline")
    ("s" org-schedule :name "schedule")) :name "date")
  ("SPC o s"
   (("s" org-edit-special :name "edit")
    ("e" org-babel-execute-src-block :name "execute")
    ("t" org-babel-tangle :name "tangle")) :name "special")
  (:mode 'org-src-mode)
  ("SPC o o" org-edit-src-exit :name "exit")
  ("SPC o O" org-edit-src-abort :name "without saving")
  :hook
  (org-mode . variable-pitch-mode)
  (org-mode . org-indent-mode)
  (org-mode . visual-line-mode)
  (org-mode . auto-fill-mode)
  (org-mode . ndk/set-header-line-format)
  :custom-face
  (org-code ((t (:inherit 'fixed-pitch))))
  (org-tag ((t (:inherit 'org-code))))
  (org-table ((t (:inherit 'org-code))))
  (org-verbatim ((t (:inherit 'org-code))))
  (org-ellipsis ((t (:underline nil))))
  (org-meta-line ((t (:inherit 'org-code :extend t))))
  (org-block ((t (:inherit 'fixed-pitch))))
  (org-block-begin-line ((t (:inherit 'fixed-pitch))))
  (org-block-end-line ((t (:inherit 'org-block-begin-line))))
  :config
  (setq org-ellipsis " ➕")
  (setq org-directory "~/Documents/Org/")
  (setq line-spacing 0.25)
  <<org-agenda>>
  <<org-templates>>
  <<org-literate>>)

#+END_SRC

*** Breadcrumbs

I'm including an Org breadcrumb setup so I don't lose track of what heading I'm actually in.

The code is lifted directly from [[https://emacs.stackexchange.com/a/61107][this Stack Overflow answer]].

#+NAME: org-breadcrumbs
#+BEGIN_SRC emacs-lisp :tangle no

(defun ndk/heading-title ()
  "Get the heading title."
  (save-excursion
    (if (not (org-at-heading-p))
  (org-previous-visible-heading 1))
    (org-element-property :title (org-element-at-point))))

(defun ndk/org-breadcrumbs ()
  "Get the chain of headings from the top level down
    to the current heading."
  (let ((breadcrumbs (org-format-outline-path
                      (org-get-outline-path)
                      (1- (frame-width))
                      nil " ⟼ "))
        (title (ndk/heading-title)))
    (if (string-empty-p breadcrumbs)
        title
      (format "%s ⟼ %s" breadcrumbs title))))

(defun ndk/set-header-line-format()
  (setq header-line-format '(:eval (ndk/org-breadcrumbs))))

#+END_SRC

*** Agenda

Now, I set up Org for task management.

#+NAME: org-agenda
#+BEGIN_SRC emacs-lisp :tangle no

;;; Org agenda flow
(setq org-agenda-start-with-log-mode t)
(setq org-log-done 'time)
(setq org-log-into-drawer t)

(setq org-agenda-files '("~/Documents/Org/Projects.org" "~/Documents/Org/Done.org"))

(setq org-todo-keywords
      '((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d!)")
        (sequence
         "BACKLOG(b)" "PLAN(p)" "READY(r)" "ACTIVE(a)" "REVIEW(v)"
         "WAIT(w@/!)" "HOLD(h)" "|" "COMPLETED(c)" "CANC(k@)")))

(setq org-refile-targets '((org-agenda-files :maxlevel . 3)))

(setq org-tag-alist
      '((:startgroup)
        ("@product" . ?P)
        ("@experiment" . ?E)
        ("@resource" . ?R)
        ("@learning" . ?L)
        ("@teaching" . ?T)
        (:endgroup)
        ("prototyping" . ?p)
        ("developing" . ?d)
        ("documenting" . ?D)
        ("testing" . ?t)
        ("refactoring" . ?r)))

(setq org-agenda-custom-commands
      '(("d" "Dashboard"
   ((agenda "" ((org-deadline-warning-days 7)))
          (todo "NEXT"
                ((org-agenda-overriding-header "Next Tasks")))))

  ("P" "Products" tags-todo "@product")
        ("E" "Experiments" tags-todo "@experiment")
        ("R" "Resources" tags-todo "@resource")
        ("L" "Learning" tags-todo "@learning")
        ("T" "Teaching" tags-todo "@teaching")

        ("s" "Workflow Status"
         ((todo "WAIT"
                ((org-agenda-overriding-header "Waiting on External")
     (org-agenda-files org-agenda-files)))
          (todo "REVIEW"
                ((org-agenda-overriding-header "Under Review")
     (org-agenda-files org-agenda-files)))
          (todo "PLAN"
                ((org-agenda-overriding-header "Planning")
     (org-agenda-files org-agenda-files)))
          (todo "BACKLOG"
                ((org-agenda-overriding-header "Project Backlog")
     (org-agenda-files org-agenda-files)))
          (todo "READY"
                ((org-agenda-overriding-header "Ready for Work")
     (org-agenda-files org-agenda-files)))
          (todo "ACTIVE"
                ((org-agenda-overriding-header "Active Projects")
     (org-agenda-files org-agenda-files)))
          (todo "COMPLETED"
                ((org-agenda-overriding-header "Completed Projects")
     (org-agenda-files org-agenda-files)))
          (todo "CANC"
                ((org-agenda-overriding-header "Cancelled Projects")
     (org-agenda-files org-agenda-files)))))))

#+END_SRC

*** Refiling

Refiling is a feature that can help me for more than moving things across files. It can also help me
restructure current files, so I'm setting it up for that. This is taken from Sacha Chua's dotemacs.

#+NAME: org-refiling
#+BEGIN_SRC emacs-lisp

;;; Refiling setup
(setq org-refile-use-outline-path 'file)
(setq org-outline-path-complete-in-steps nil)
(setq org-refile-allow-creating-parent-nodes 'confirm)

;; Refile from current file
(defun my/org-refile-in-file (&optional prefix)
  "Refile to a target within the current file."
  (interactive)
  (let ((org-refile-targets `(((,(buffer-file-name)) :maxlevel . 6))))
    (call-interactively 'org-refile)))

;; Save all buffers after a refile
(advice-add 'org-refile :after 'org-save-all-org-buffers)

#+END_SRC

*** Capture Templates

In this section, I'm defining my Org-capture templates. It's just the one right now, but more will be added as
I need them.

#+NAME: org-templates
#+BEGIN_SRC emacs-lisp :tangle no

;;; Org template definitions
(setq org-capture-templates
      `(("t" "Tasks / Projects")
        ("tt" "Task" entry (file+olp "Tasks.org" "Inbox")
         "* TODO %?\n %U\n %a\n %i" :empty-lines 1)))

#+END_SRC

*** Literate Programming

Finally, I set my configuration up for Org-babel so I can do literate programming in any language I want.

#+NAME: org-literate
#+BEGIN_SRC emacs-lisp :tangle no

;;; Org-babel setup
(setq org-src-fontify-natively t)
(setq org-confirm-babel-evaluate nil)
(setq org-src-tab-acts-natively t)
(setq org-src-preserve-indentation t)
(setq org-babel-lisp-eval-fn #'sly-eval)

;;; Supported languages
(org-babel-do-load-languages
 'org-babel-load-languages
 '((emacs-lisp . t)
   (lisp . t)
   (scheme . t) ;; TODO: figure out how to load Scheme with Geiser
   (C . t)
   (shell . t)
   (js . t)))

#+END_SRC

#+RESULTS: org-literate

*** Interface Addons
**** org-superstar

Org Superstar is a package that makes Org Mode bullets (even lists) much prettier.

#+BEGIN_SRC emacs-lisp

;;; Org Superstar makes your bullets bang louder
(use-package org-superstar
  :after org
  :hook
  (org-mode . org-superstar-mode)
  :custom-face
  (org-superstar-leading ((t (:inherit 'org-hide))))
  :init
  (setq org-superstar-headline-bullets-list
        '("♠" "♥" "♣" "♦")))

#+END_SRC

**** visual-fill-column

This package provides a more pleasant writing experience with Org Mode. I used darkroom for a while,
but it does a little too much and doesn't seem to play nice with org-indent-mode.

#+BEGIN_SRC emacs-lisp
;;; Org mode line length
(defvar C4/org-measure
  (C4/round-height (* C4/font-size-doc C4/font-ratio)))

;;; visual-fill-column does just enough UI adjustment for Org Mode
(use-package visual-fill-column
  :custom
  (visual-fill-column-width C4/org-measure)
  (visual-fill-column-center-text t)
  :hook
  (visual-line-mode . visual-fill-column-mode)
  (org-mode . (lambda () (setq fill-column C4/org-measure)))
  :config
  (advice-add 'text-scale-adjust :after #'visual-fill-column-adjust))

#+END_SRC

**** toc-org

This package enables me to add a table of contents to Org files.

#+BEGIN_SRC emacs-lisp

;;; Add support for a table of contents
(use-package toc-org
  :after org
  :hook
  (org-mode . toc-org-mode))

#+END_SRC

*** Journaling

I include Org Journal, because I want to commit to keeping better notes and cultivate a habit of
note-taking in an environment I know I won't abandon easily.

#+BEGIN_SRC emacs-lisp

;;; Journal file header
(defun C4/org-journal-file-header (time)
  "Custom function to create a journal header."
  (concat
   (pcase org-journal-file-type
     (`daily "#+TITLE: Daily Journal\n#+STARTUP: showeverything\n")
     (`weekly "#+TITLE: Weekly Journal\n#+STARTUP: folded\n")
     (`monthly "#+TITLE: Monthly Journal\n#+STARTUP: folded\n")
     (`yearly "#+TITLE: Yearly Journal\n#+STARTUP: folded\n"))))

;;; Add journaling support to Org Mode
(use-package org-journal
  :ryo
  ("SPC o j"
   (("j" org-journal-new-entry :name "new")
    ("J" org-journal-read-entry :name "read")
    ("n" org-journal-next-entry :name "next")
    ("p" org-journal-previous-entry :name "prev")
    ("s" org-journal-search :name "search")
    ("c" calendar :name "calendar")) :name "journal")
  :custom
  ;; Files
  (org-journal-dir "~/Documents/Org/Notes/Journal/")
  (org-journal-file-format "%V|%F.org")

  ;; Entries
  (org-journal-file-header 'C4/org-journal-file-header)

  ;; Org agenda integration
  (org-journal-enable-agenda-integration t))

#+END_SRC

*** Notes
**** org-roam

Another vital component of my note-taking workflow: org-roam.

#+BEGIN_SRC emacs-lisp

;;; Setup org-roam for starting a knowledge base
(use-package org-roam
  :after org
  :ryo
  (:mode 'org-roam-mode)
  ("SPC o n"
   (("n" org-roam-buffer-toggle-display :name "toggle")
    ("b" org-roam-switch-to-buffer :name "switch")
    ("f" org-roam-find-file :name "find file")
    ("g" org-roam-graph :name "graph")
    ("l" org-roam-insert :name "link")
    ("L" org-roam-insert-immediate :name "and create note")) :name "roam")
  :hook
  (after-init . org-roam-mode)
  :custom
  (org-roam-directory "~/Documents/Org/Notes/Roam/")
  :init
  (setq org-roam-v2-ack t))

#+END_SRC

**** deft

The final piece of the puzzle is deft. This package allows me to perform fast text searches across
all of my Org notes. The main advantage: I get an overview of topics and thoughts I fixate on by how
many times they recur, for better or worse.

#+BEGIN_SRC emacs-lisp

;;; Deft for quick pattern-based note searching
(use-package deft
  :ryo
  ("SPC o q" deft :name "query")
  :commands (deft)
  :custom
  (deft-extensions '("org"))
  (deft-directory "~/Documents/Org/Notes/")
  (deft-use-filename-as-title t)
  (deft-recursive t))

#+END_SRC

*** Publishing

Sometimes, I want to share thoughts with people. This section features packages that help me get my
voice out into the world a bit more.

**** weblorg

This is a fairly new package in the vein of =ox-hugo= or =org-page=. It's a full Emacs Lisp
static site generator from Org Mode! Some of the features that really excite me include completely
custom HTML templates. I mean, I did start as a web designer.

Weblorg allows me to use my entire front-end development toolkit to build and publish a sweet Org
Mode website. Publishing a thought is as easy as writing one.

So I have no excuse not to write anymore.

#+BEGIN_SRC emacs-lisp

;;; An Org Mode static site generator
(use-package weblorg)

#+END_SRC

* Programming Modes

The richer programming experience offered by Emacs and the lovely ecosystem of community packages
was a huge part of why I switched over from Vim after nearly a decade of use. It requires a bit of
setup, but now I have a development workstation I can grow with and easily expand.

I also have a much, /much/ easier time understanding and modifying Emacs Lisp packages for my personal
ends than I ever did with VimScript.

I looked around for packages that set a solid base for programming in general before I started
looking for language-specific support. That way each language I use gets a good starting point from
which I can selectively improve the workflow as needed.

Each programming major mode I use wraps its frequently-used commands under =SPC l=.

** Paths

I've recently found that I needed to explicitly set my paths.

#+BEGIN_SRC emacs-lisp
(use-package exec-path-from-shell
  :if window-system
  :config (exec-path-from-shell-initialize))
#+END_SRC

** Parsing

Somewhat unconventional from other configurations is my inclusion of the tree-sitter package for Emacs. I
include it not just for the faster granular highlighting, but also because it allows me to /query/ syntax
definitions in supported source code.

While this would be a curiosity for most developers, it's a boon for developers thinking about creating new
programming languages or external *DSLs*. This is a space I've started to explore in my work, so in it goes.

As a bonus, some of the languages I use most come with support out of the box.

#+BEGIN_SRC emacs-lisp

;;; A full on parser in Emacs with highlighting definitions
(use-package tree-sitter
  :config
  (global-tree-sitter-mode 1))

;; A collection of supported tree-sitter languages
(use-package tree-sitter-langs
  :after tree-sitter)

#+END_SRC

** Syntax Highlighting

This section contains packages with the aim of providing a little more contextual highlighting to programming
modes. Since I use a default theme that doesn't make a lot of assumptions about how I want my code
highlighted, it means I can judiciously add syntax information that actually helps rather than creates noise.

*** Faces

I'm going to adjust a few faces provided by tree-sitter now.

#+BEGIN_SRC emacs-lisp
;;; Set syntax highlighting faces

;; set comment face
(set-face-attribute 'font-lock-comment-face nil
        :slant 'italic
        :weight 'light
        :foreground (ewal-load-color 'red))

;; set keyword face
(set-face-attribute 'font-lock-keyword-face nil :foreground (ewal-load-color 'blue))

;; set function name face
(set-face-attribute 'font-lock-function-name-face nil :weight 'bold :foreground (ewal-load-color 'yellow))

;; set string face
(set-face-attribute 'font-lock-string-face nil :slant 'italic :foreground (ewal-load-color 'green))

;; set docstring face
(set-face-attribute 'font-lock-doc-face nil :weight 'bold)

;; set constants face
(set-face-attribute 'font-lock-constant-face nil :inherit 'font-lock-function-name-face)

;; set built-in face
(set-face-attribute 'font-lock-builtin-face nil :inherit 'font-lock-keyword-face)

;; set variable name face
(set-face-attribute 'font-lock-variable-name-face nil :inherit 'font-lock-function-name-face)

#+END_SRC

*** rainbow-delimiters

This package is incredibly helpful in keeping track of how many levels deep I am in a complex LISP s-exp and it
helps a little in other ways, too.

#+BEGIN_SRC emacs-lisp

;;; When I'm knee deep in parens
(use-package rainbow-delimiters
  :hook
  (prog-mode . rainbow-delimiters-mode)
  (prog-mode . prettify-symbols-mode))

#+END_SRC

***  color-identifiers-mode

This package is another highlighting enhancement that enables semantic highlighting by identifiers
instead of syntax. Another one of those little things that helps me code and keep track of things in
source.

#+BEGIN_SRC emacs-lisp

;;; Helps me remember the names of things
(use-package color-identifiers-mode
  :hook
  (prog-mode . color-identifiers-mode))

#+END_SRC

** Linting

C4 uses flycheck for code linting.

#+BEGIN_SRC emacs-lisp

;;; Code linting package that flies
(use-package flycheck
  :hook (prog-mode . flycheck-mode))

#+END_SRC

** Formatting
*** apheleia

C4 uses Apheleia for code formatting. It's a language-agnostic formatting package that allows the support of
new formatters as well.

#+BEGIN_SRC emacs-lisp

;;; Universal code formatting package
(use-package apheleia
  :straight
  '(apheleia
    :host github
    :repo "raxod502/apheleia")
  :hook (prog-mode . apheleia-mode))

#+END_SRC

*** smartparens

This package auto-pairs delimiters for a variety of programming modes.

#+BEGIN_SRC emacs-lisp

;;; Autopair delimiters
(use-package smartparens
  :hook
  (prog-mode . smartparens-mode)
  :config
  (require 'smartparens-config))

#+END_SRC

*** aggressive-indent-mode

Automatic indentation is another sanity check for overall programming. Especially in Lisp modes.

#+BEGIN_SRC emacs-lisp

;;; Automatic indentation for my sanity
(use-package aggressive-indent
  :hook
  (prog-mode . aggressive-indent-mode))

#+END_SRC

** Autocompletion

Autocompletion used to be provided by Company, but then I realized the built-in =eldoc= really ain't
that bad at its job and, unlike Company, only shows up when I need it.

** Language Server Protocol

Language Server Protocol is /the/ killer feature of modern IDEs. The most significant contribution of VSCode
can be used in Emacs without much issue.

First, I'm setting it up for general use. Later, in the appropriate language's section, I add the enhancements.

#+BEGIN_SRC emacs-lisp

;;; Language Server Protocol package for rich IDE features

;; Setup eglot: a lightweight LSP client
(use-package eglot
  :ryo
  (:mode 'eglot--managed-mode)
  ("SPC l l"
   (("c" eglot :name "connect")
    ("C" eglot-reconnect :name "restart")
    ("C-c" eglot-shutdown :name "shutdown")
    ("e"
     (("e" eglot-events-buffer :name "show events")
      ("E" eglot-stderr-buffer :name "show errors")
      ("c" eglot-signal-didChangeConfiguration :name "reload workspace config")) :name "client actions")
    ("a" eglot-code-actions :name "code actions")
    ("r" eglot-rename :name "rename symbol")
    ("f" eglot-format :name "format")
    ("d" eldoc :name "documentation")) :name "LSP"))

#+END_SRC

** Snippets

Snippets are valuable for my workflow. And YASnippet is the Emacs standard for using them. I also
included Auto-YASnippet to create custom snippets as needed.

The commands for snippet creation are enabled across all programming modes under the =SPC s= prefix.

#+BEGIN_SRC emacs-lisp

(defun C4/create-one-liner ()
  "Create a one line snippet to expand immediately."
  (interactive)
  (aya-create-one-line))

(defun C4/expand-snippet ()
  "Expand the last created snippet and fill it in."
  (interactive)
  (aya-expand))

(defun C4/save-snippet ()
  "Save the created snippet to database."
  (interactive)
  (aya-persist-snippet)
  (yas/reload-all))

;;; Snippet support

;; Setup YASnippet
(use-package yasnippet
  :hook
  (prog-mode . yas-minor-mode))

;; Setup Auto-YASnippet
(use-package auto-yasnippet
  :ryo
  (:mode 'prog-mode)
  (:mode 'html-mode)
  ("SPC s"
   (("s" aya-create :name "create")
    ("e" C4/expand-snippet :name "expand" :exit t)
    ("w" C4/save-snippet :name "save")) :name "snippet"))

#+END_SRC

** Language Support

The groundwork is in place, so now I'm going to selectively enhance some programming modes. The
language support of my configuration includes languages I use regularly and those I want to study.

*** Lisp Family
**** Emacs Lisp

Having a good Emacs Lisp experience ensures I'll want to keep editing and improving this
configuration. A few packages are available to enhance Emacs' own programming language.

The main one is Eros.

#+BEGIN_SRC emacs-lisp

;;; Lang: Emacs Lisp

;; Inline Emacs Lisp evaluation results
(use-package eros
  :mode ("\\.el\\'" . emacs-lisp-mode)
  :ryo
  (:mode 'emacs-lisp-mode)
  ("SPC l"
   (("e"
     (("e" eros-eval-last-sexp :name "expression")
      ("d" eros-eval-defun :name "defun")) :name "eval")) :name "emacs-lisp")
  :hook
  (emacs-lisp-mode . eros-mode)
  (lisp-interaction-mode . eros-mode))

#+END_SRC

**** Common Lisp

The premier package for editing Common Lisp is SLIME, and I'm using a newer, actively maintained
fork called SLY in my configuration.

#+BEGIN_SRC emacs-lisp

;;; Lang: Common Lisp

;; Setup SLY
(use-package sly
  :mode ("\\.lisp\\'" . lisp-mode)
  :ryo
  (:mode 'lisp-mode)
  ("SPC l"
   ;; Connections
   (("C"
     (("c" sly :name "invoke")
      ("l" sly-list-connections :name "list active")
      (">" sly-next-connection :name "next")
      ("<" sly-prev-connection :name "prev"))
     :name "connections")

    ;; Annotations
    ("a"
     (("a" sly-next-note :name "next")
      ("A" sly-previous-note :name "prev")
      ("C-a" sly-remove-notes :name "remove all")) :name "annotations")

    ;; Docs
    ("d"
     (("d" sly-autodoc-mode :name "autodoc toggle")
      ("m" sly-autodoc-manually :name "autodoc manually")
      ("a" sly-arglist :name "arglist")
      ("s" sly-info :name "SLY manual")) :name "docs")

    ;; Compiling
    ("c"
     (("c" sly-compile-defun :name "defun")
      ("r" sly-compile-region :name "region")
      ("f" sly-compile-file :name "file")
      ("F" sly-compile-and-load-file :name "and load")) :name "compile")
    ("E" next-error :name "show errors")

    ;; Evaluation
    ("e"
     (("e" sly-eval-last-expression :name "expression")
      ("E" sly-pprint-eval-last-expression :name "to buffer")
      ("i" sly-interactive-eval :name "interactive")
      ("d" sly-eval-defun :name "defun")
      ("r" sly-eval-region :name "region")
      ("R" sly-pprint-eval-region :name "to buffer")
      ("b" sly-eval-buffer :name "buffer")) :name "eval")

    ;; Files
    ("f" sly-load-file :name "load file")

    ;; Macros
    ("m"
     (("m" sly-expand-1 :name "expand")
      ("M" sly-macroexpand-all :name "all")
      ("c" sly-compiler-macroexpand-1 :name "compiler expand")
      ("C" sly-compiler-macroexpand :name "repeatedly")
      ("f" sly-format-string-expand :name "format string")
      ("r" sly-macroexpand-1-inplace :name "recursive expand")
      ("R" sly-macroexpand-again :name "repeat last")
      ("u" sly-macro-expand-undo :name "undo last")) :name "macro")

    ;; Definitions
    ("d"
     (("d" sly-describe-symbol :name "symbol")
      ("f" sly-describ-function :name "function")
      ("a" sly-apropos :name "apropos")
      ("A" sly-apropos-all :name "with globals")
      ("C-a" sly-apropos-package :name "package")
      ("h" sly-hyperspec-lookup :name "hyperspec lookup")
      ("H" sly-hyperspec-lookup-format :name "format")
      ("C-h" sly-hyperspec-lookup-reader-macro :name "reader macro"))
     :name "definitions")

    ;; Cross-reference
    ("x"
     (("x" sly-edit-uses :name "symbol")
      ("c" sly-who-calls :name "callers")
      ("C" sly-calls-who :name "callees")
      ("g" sly-who-references :name "global")
      ("G" sly-who-binds :name "global bindings")
      ("C-g" sly-who-sets :name "global assignments")
      ("m" sly-who-macroexpands :name "macroexpansions")
      ("M" sly-who-specializes :name "methods")) :name "x-ref"))
   :name "common-lisp")
  :hook
  (lisp-mode . sly-mode)
  :config
  (setq inferior-lisp-program "/home/cr-jr/.guix-extra-profiles/work/work/bin/sbcl")

  (sly))
#+END_SRC

**** Racket

For editing Racket source, racket-mode is the way to go.

#+BEGIN_SRC emacs-lisp

;;; Lang: Racket

;; Initialize racket-mode
(use-package racket-mode
  :mode ("\\.rkt\\'" . racket-mode)
  :interpreter ("racket" . racket-mode)
  :ryo
  (:mode 'racket-mode)
  ("SPC l"
   ;; Run
   (("r"
     (("r" racket-run :name "run")
      ("R" racket-run-and-switch-repl :name "and switch to REPL")
      ("m" racket-run-module-at-point :name "module")) :name "program")

    ;; Eval
    ("e"
     (("e" racket-send-last-sexp :name "exprssion")
      ("d" racket-send-definition :name "definition")
      ("r" racket-send-region :name "region")) :name "eval")

    ;; Testing
    ("t"
     (("t" racket-test :name "run")
      ("z" racket-fold-all-tests :name "fold")
      ("Z" racket-unfold-all-tests :name "unfold")) :name "tests")) :name "racket")
  :custom
  (racket-program "~/.guix-extra-profiles/work/work/bin/racket")
  :init
  (setq tab-always-indent 'complete)
  :hook
  (racket-mode . racket-xp-mode)
  (racket-mode . racket-smart-open-bracket-mode)
  (racket-mode . racket-unicode-input-method-enable)
  (racket-repl-mode . racket-unicode-input-method-enable))

;; Racket Org mode support
(use-package ob-racket
  :straight (ob-racket :host github :repo "DEADB17/ob-racket")
  :after org
  :config
  (add-to-list 'org-babel-load-languages '(racket . t))
  (add-to-list 'org-babel-load-languages '(scribble . t)))

#+END_SRC

**** Guile

Guile came on my radar around the same time I discovered GNU Guix. I'm hype about the possibilities
of immutable and reproducible system configurations as well as the prospect of planning *future
systems* for hardware and architectures I /may/ use.

Also, the Guile flavor or Lisp itself is great.

#+BEGIN_SRC emacs-lisp
;;; Lang: Guile

(use-package geiser-guile
  :after geiser
  :mode ("\\.scm\\'" . scheme-mode)
  :interpreter ("guile" . scheme-mode)
  :hook
  (scheme-mode . geiser-mode)
  :config
  (setq geiser-default-implementation 'guile))

(use-package macrostep-geiser :after geiser)
#+END_SRC

*** Web Dev

For web development, essential packages include: emmet-mode, skewer-mode, and impatient-mode.

I don't use specialized template syntax, so I don't have much use for web-mode.

#+BEGIN_SRC emacs-lisp

;;; Lang: HTML/CSS/Web

;; Setup skewer-mode
(use-package skewer-mode
  :ryo
  (:mode 'skewer-mode)
  ("SPC l s"
   (("s" skewer-load-buffer :name "load")
    ("c" run-skewer :name "connect")
    ("C" skewer-run-phantomjs :name "headless")
    ("e" skewer-eval-last-expression :name "evaluate expression")
    ("E" skewer-eval-defun :name "evaluate function")
    ("r" skewer-repl :name "run")) :name "skewer")
  (:mode 'skewer-html-mode)
  ("SPC l"
   (("l" skewer-html-eval-tag :name "eval")
    ("e" skewer-html-fetch-selector-into-buffer :name "expand innerHTML"))
   :name "HTML")
  (:mode 'skewer-css-mode)
  ("SPC l"
   (("l" skewer-css-eval-current-declaration :name "declaration")
    ("L" skewer-css-eval-current-rule :name "rule")
    ("C-l" skewer-css-eval-buffer :name "buffer")
    ("M-l" skewer-css-clear-all :name "clear all"))
   :name "CSS")
  :hook
  (js-mode . skewer-mode)
  (html-mode . skewer-html-mode)
  (css-mode . skewer-css-mode))

;; Setup emmet-mode
(use-package emmet-mode
  :hook
  (html-mode . emmet-mode)
  (css-mode . emmet-mode))

;; Setup impatient-mode
(use-package impatient-mode
  :ryo
  (:mode 'impatient-mode)
  ("SPC l"
   (("c" httpd-start :name "connect")
    ("C" httpd-stop :name "disconnect")
    ("C-c" httpd-serve-directory :name "serve from dir")))
  :hook
  (html-mode . impatient-mode))

;; Add support for Org babel
(use-package ob-html
  :straight (ob-html :host github :repo "misohena/ob-html")
  :after org
  :config
  (setq org-babel-html-chrome-executable "/home/cr-jr/.guix-profile/bin/chromium")
  (append '((html . t)) org-babel-load-languages))

#+END_SRC

*** JavaScript/TypeScript

Now, I'll beef up the JS dev experience. I'm investing heavily into =deno= this year, so my
configuration optimizes for a =deno= workflow.

**** Setup

The main package for JS is js2-mode. This either replaces or augments the built-in =js-mode=. I'm
choosing to do the latter. For LSP features, Deno =>=1.6= includes its own server: =deno lsp=.

I wire up eglot to trigger on every JS/TS buffer in the current project. As well as let it know about
=deno lsp= and what settings it expects to work.

@taiju already wrote =ob-deno= for [[https://github.com/taiju/ob-deno][literate JS programming powered by the Deno runtime]], so I don't
have to. Though, I did fork it for my own adjustments.

#+BEGIN_SRC emacs-lisp

;;; Lang: JavaScript

;; Setup js2-mode and use it to augment the built-in mode
(use-package js2-mode
  :mode ("\\.js\\'" . js-mode)
  :interpreter ("deno" . js-mode)
  :ryo
  (:mode 'js-mode)
  ("SPC l" nil :name "javascript")
  :hook
  (js-mode . js2-minor-mode)
  (js-mode . eglot-ensure)
  :config
  ;; Setup deno built-in LSP for eglot
  (defclass eglot-deno (eglot-lsp-server) ()
    :documentation "A custom class for handling Deno's built-in LSP server")

  ;; Deno requires the :enable keyword to connect, but I also want to include
  ;; the built-in linting and begin with good habits since I'm new to the space.
  (cl-defmethod eglot-initialization-options ((server eglot-deno))
    "Passes through required deno initialization options."
    (let* ((root (car (project-roots (eglot--project server))))
     (cache (expand-file-name ".deno/lsp/cache/" root)))
      (list :enable t :lint t)))

  ;; Note: The deno lsp JavaScript language identifier is NOT "js", so eglot's
  ;; guess ("js" for js-mode) was incorrect and the server wouldn't load
  (add-to-list
   'eglot-server-programs '((js-mode :language-id "javascript") . (eglot-deno "deno" "lsp")))

  (add-hook
   'js-mode-hook (lambda () (add-hook 'before-save-hook 'eglot-format-buffer))))

;; Setup typescript-mode
(use-package typescript-mode
  :after js2-mode
  :mode ("\\.ts\\'" . typescript-mode)
  :interpreter ("deno" . typescript-mode)
  :ryo
  (:mode 'typescript-mode)
  ("SPC l" nil :name "typescript")
  :hook
  (typescript-mode . eglot-ensure)
  :config
  (add-to-list
   'eglot-server-programs '(typescript-mode . (eglot-deno "deno" "lsp")))

  (add-hook
   'typescript-mode-hook (lambda () (add-hook 'before-save-hook 'eglot-format-buffer))))

;; Support literate programming with TypeScript
(use-package ob-typescript
  :after org
  :config
  (add-to-list 'org-babel-load-languages '(typescript . t)))

;; Literate programming with the deno runtime
(use-package ob-deno
  :after org
  :straight '(ob-deno :host github :repo "cr-jr/ob-deno")
  :config
  (add-to-list 'org-babel-load-languages '(deno . t))
  (add-to-list 'org-src-lang-modes '("deno" . js))
  (add-to-list 'org-src-lang-modes '("deno" . typescript)))

;; Setup json-mode
(use-package json-mode
  :mode
  ("\\.json\\'" . json-mode)
  ("\\.jsonp\\'" . json-mode))

#+END_SRC

*** Raku

Raku, formerly known as Perl 6, is uncharted territory. I've never encountered a language like
it. That in itself excites me enough to dip my toes in. Thankfully, there are basic packages
available for getting set up.

I did some more looking around and found a package from @ohmycloud. I'm gonna see how well it covers
my use cases (for now just learning Raku), but it'll serve as a good base if I want to build on it.

#+BEGIN_SRC emacs-lisp
;;; Lang: Raku

;; Setup raku-mode
(use-package raku-mode
  :mode
  ("\\.rakumod\\'" . raku-mode)
  ("\\.raku\\'" . raku-mode)
  :interpreter ("raku" . raku-mode)
  :ryo
  (:mode 'raku-mode)
  ("SPC l"
   (("e"
     (("e" raku-send-line-to-repl :name "line")
      ("r" raku-send-region-to-repl :name "region")
      ("b" raku-send-buffer-to-repl :name "buffer")) :name "eval")
    ("m" raku-mode-menu :name "menu")) :name "raku")
  :config
  (set-face-attribute 'raku-identifier nil :inherit 'fixed-pitch))

;; Add flycheck completion
(use-package flycheck-raku)

;; Literate programming with Raku
(use-package ob-raku
  :after org
  :straight '(ob-raku :host github :repo "cr-jr/ob-raku")
  :config
  (add-to-list 'org-babel-load-languages '(raku . t))
  (add-to-list 'org-src-lang-modes '("raku" . raku)))

#+END_SRC

** rainbow-mode

Since I work with colors a lot, I thought it would be a great idea to pull in this handy package.

#+BEGIN_SRC emacs-lisp
(use-package rainbow-mode
  :hook
  (prog-mode . rainbow-mode))
#+END_SRC

* Guix

GNU Guix is a functional package manager written in Guile Scheme. It's also an entire operating
system. This section is for packages that help me work with Guix much easier.

#+BEGIN_SRC emacs-lisp
;;; Guix

(use-package guix
  :hook
  (scheme-mode . guix-devel-mode)
  :config
  (with-eval-after-load 'geiser-guile
    (add-to-list 'geiser-guile-load-path "~/Code/guix")))
#+END_SRC
