#+TITLE: C4 Configuration
#+DATE: 2021-01-23
#+AUTHOR: Chatman R. Jr
:PROPERTIES:
:header-args: :mkdirp yes
:END:

* Summary

This configuration builds off my experience with [[https://github.com/hlissner/doom-emacs][Doom Emacs]], and is heavily informed by code from
the [[https://github.com/daviwil/emacs-from-scratch][Emacs from Scratch project]]. It's my personal configuration/Emacs Lisp study reference as I learn.

C4 is a middle ground between vanilla Emacs (which isn't all that useful for me by itself) and whole
batteries-included frameworks and distributions (such as Doom Emacs and Spacemacs).

It does just enough.

C4 is based on my real day to day needs and prioritizes ease, convenience and performance. If any
included functionality doesn't add value to my workflow, it's gone. Like that.

* Initialization

  C4 is a module-based configuration, so the very first thing it does is load in its own modules.

#+BEGIN_SRC emacs-lisp :tangle "./early-init.el"
(require 'cl-lib)

(require 'preamble
          (concat user-emacs-directory "modules/preamble.el"))
(require 'base
          (concat user-emacs-directory "modules/base.el"))
(require 'keybindings
          (concat user-emacs-directory "modules/keybindings.el"))
(require 'projects
          (concat user-emacs-directory "modules/projects.el"))
(require 'code
          (concat user-emacs-directory "modules/code.el"))
(require 'documents
          (concat user-emacs-directory "modules/documents.el"))
(require 'desktop
          (concat user-emacs-directory "modules/desktop.el"))
#+END_SRC

* Modules

** Preamble

The =preamble.el= module contains a few defaults and performance optimizations that should be done
before anything else happens.

*** ~c4/perf~

The first optimization involves increasing the Emacs garbage collection threshold to 100MB on
startup. This gives a slight boost in initialization. After Emacs starts up, we use a hook to reduce
the threshold back to its approximate initial state.

#+NAME: c4/perf
#+BEGIN_SRC emacs-lisp :tangle "./modules/preamble.el"
(defun c4/perf ()
  "Handles performance optimizations"

  ;; Raise the garbage collection threshold high as emacs starts
  (setq gc-cons-threshold 100000000)
  (setq read-process-output-max (* 1024 1024))

  ;; Drop it down once loaded
  (add-hook 'after-init-hook #'(lambda () (setq gc-cons-threshold 1000000))))
#+END_SRC

*** ~c4/packages-setup~

Next, we handle all package management with [[https://github.com/raxod502/straight.el][straight.el]] and package configuration with
[[https://github.com/jwiegley/use-package][use-package]]. This configuration *does not use package.el at all*.

#+BEGIN_SRC emacs-lisp :tangle "./modules/preamble.el"

(defun c4/packages-setup ()
  "Initializes package management with straight.el & use-package."
  ;; Initialize straight.el for package management
  (setq straight-repository-branch "develop")
  (defvar bootstrap-version)
  (let ((bootstrap-file
        (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
        (with-current-buffer
            (url-retrieve-synchronously
            "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
            'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))

  ;; use-package integration
  (straight-use-package 'use-package)
  (setq straight-use-package-by-default t))

#+END_SRC

*** ~c4/housekeeping~

Finally, we set a few helpful variables to inhibit lockfiles. I also disable custom files simply
because I prefer doing all of my configuration in Emacs-Lisp. Next, I add a hook to delete trailing
whitespace in my files.

There's a helper function to tell Emacs to create directories that don't exist on the filesystem for
convenience. And last but not least, [[https://github.com/emacscollective/no-littering][no-littering]] helps keep the configuration files separate from
files that Emacs may create via its packages.

In addition, it tells Emacs to keep all autosaves (which can help in a pinch) in their own directory
instead of dropping them wherever.

#+BEGIN_SRC emacs-lisp :tangle "./modules/preamble.el"

(defun c4/housekeeping ()
  "A helper for should-be-defaults"
  ;; Lockfiles do more harm than good
  (setq create-lockfiles nil)

  ;; Custom files just add clutter
  (setq custom-file null-device)

  (add-hook 'before-save-hook
    'delete-trailing-whitespace)    ; Delete trailing whitespace on save

  ;; Create parent dirs when opening new files
  (add-to-list 'find-file-not-found-functions #'c4/create-parent-on-file-find)

  ;; I really don't like clutter. Really :P
  (use-package no-littering
  :custom
  (auto-save-file-name-transforms
        `((".*" ,(no-littering-expand-var-file-name "auto-save/") t)))))

(defun c4/create-parent-on-file-find ()
  "Ensures that the parent dirs are created for a nonexistent file."
  (let ((parent-directory (file-name-directory buffer-file-name)))
    (when (and (not (file-exists-p parent-directory))
                (y-or-n-p (format
                          "Directory `%s' does not exist! Create it?"
                          parent-directory)))
      (make-directory parent-directory t))))

(provide 'preamble)
#+END_SRC

And then we call the module functions in our =init.el=.

#+BEGIN_SRC emacs-lisp :tangle "./init.el"
(c4/perf)
(c4/packages-setup)
(c4/housekeeping)

#+END_SRC

** Base

The =base.el= module sets the /baseline/ experience that C4 is intended to provide without any of
its other enhancements. This includes:

+ setting the user
+ setting the theme
+ setting the typography (code and document)
+ essential UX enhancements

*** ~c4/user~

This function sets the user identity.

#+BEGIN_SRC emacs-lisp :tangle "./modules/base.el"
(cl-defun c4/user (&key name email)
  "Define user identity."
  (setq user-full-name name
          user-full-email email))

#+END_SRC

And it's used in =init.el= like so:

#+BEGIN_SRC emacs-lisp :tangle "./init.el"

(c4/user
  :name "Chatman R. Jr"
  :email "crjr.code@protonmail.com")

#+END_SRC

*** ~c4/base~

This module is exposed to our =init.el= to create our settings for the base look and feel and also
some essential functionality. It's composed of the =ui= and =ux= modules that follow below.

#+BEGIN_SRC emacs-lisp :tangle "./modules/base.el"
(cl-defun c4/base (&key theme typography)
  (eval (c4/ui theme typography))
  (c4/ux))
#+END_SRC

We assemble it in our =init.el= like this:

#+BEGIN_SRC emacs-lisp :tangle "./init.el"

(c4/base
  :theme 'minimal-light
  :typography
  (c4/typography
    :code '("Input" 12)
    :document '("Lora" 14)))

#+END_SRC

*** ~c4/ui~

Now, we set the base UI. It accepts a theme and typography settings from the submodules documented
below.  It also sets basic options that go a long way toward making the Emacs UI look halfway decent.

#+BEGIN_SRC emacs-lisp :tangle "./modules/base.el"

(defun c4/ui (theme typography)
  "A module for the base UI."
  (setq-default cursor-type 'bar) ; default cursor as bar
  (setq-default frame-title-format '("%b")) ; window title is the buffer name

  (setq linum-format "%4d ") ; line number format
  (column-number-mode 1)
  (show-paren-mode 1) ; show closing parens by default

  (menu-bar-mode -1) ; disable the menubar
  (scroll-bar-mode -1) ; disable visible scroll bar
  (tool-bar-mode -1) ; disable toolbar
  (tooltip-mode -1) ; disable tooltips
  (set-fringe-mode 8) ; allow some space

  ;; Show line numbers in programming modes
  (add-hook 'prog-mode-hook
            (if (and (fboundp 'display-line-numbers-mode) (display-graphic-p))
                #'display-line-numbers-mode
              #'linum-mode))


  ;; Disable for document and terminal modes
  (dolist (mode '(
      org-mode-hook
      term-mode-hook
      shell-mode-hook
      treemacs-mode-hook
      vterm-mode
      eshell-mode-hook))
    (add-hook mode (lambda () (display-line-numbers-mode 0))))

  ;; Tidy up the modeline
  (use-package diminish)
  ;; And let's make it a bit sexier
  (use-package all-the-icons)

  (eval (c4/theme theme))
  (eval typography))

#+END_SRC

This is a good time to mention that C4 also contains internal modules for composing functionality
across its main modules. These submodules can be swapped in and out as needed without issue.

The UI base uses =c4/theme= and =c4/typography= submodules. Which I'll explain now.

**** ~c4/theme~

The theme submodule sets up the mode line with [[https://github.com/Malabarba/smart-mode-line][the smart-mode-line package]]. I know a lot of
configurations swear by the Doom Emacs mode line, but I wanted something lighter.

It also checks and installs a subset of themes based on the prefix of the themes passed in. Right
now, the themes supported are the [[https://gitlab.com/protesilaos/modus-themes][modus]], [[https://github.com/hlissner/emacs-doom-themes][Doom]], and [[https://github.com/anler/minimal-theme][minimal]] (the default) collections. As well as the built-in themes
that ship with Emacs.

The last thing it does is disable the fringe background for that extra bit of crispness.

#+BEGIN_SRC emacs-lisp :tangle "./modules/base.el"

(defun c4/theme (theme)
  "A submodule for setting a theme and configuring the modeline."
  (setq theme-sym (symbol-name theme))

  (use-package smart-mode-line
    :custom
    (sml/theme 'respectful)
    (sml/no-confirm-load-theme t)
    (sml/name-width 64)
    (sml/mode-width 'full)
    :config
    (sml/setup)
    (add-to-list 'sml/replacer-regexp-list '("^~/.config/emacs/" ":C4:") t)
    (add-to-list 'sml/replacer-regexp-list '("^~/Workbench/" ":Code:") t)
    (add-to-list 'sml/replacer-regexp-list '("^~/Org/" ":Org:") t))

  (cond ((string-prefix-p "modus" theme-sym)
	 (use-package modus-themes
	   :config
	   (load-theme theme t)))
  ((string-prefix-p "minimal" theme-sym)
    (use-package minimal-theme
      :config (load-theme theme t)))
	((string-prefix-p "doom" theme-sym)
	 (use-package doom-themes
	   :config (load-theme theme t)))
	  (t (load-theme theme t)))

  (set-face-attribute 'fringe nil :background nil))

#+END_SRC


**** ~c4/typography~

This submodule defines typography settings for the UI. It allows you to set the fixed pitch (which
is also the default font) as well as the variable pitch (for Org and other document modes).

#+BEGIN_SRC emacs-lisp :tangle "./modules/base.el"

  (cl-defun c4/typography (&key code document)
    "A module for setting typography."
    (set-face-attribute 'default nil
      :font (format "%s-%s:slant=normal" (car code) (cadr code)))
    (set-face-attribute 'fixed-pitch nil
      :font (format "%s-%s" (car code) (cadr code)))
    (set-face-attribute 'variable-pitch nil
      :font (format "%s-%s" (car document) (cadr document))))

#+END_SRC

*** ~c4/ux~

The base UX module that sets some defaults to prevent Emacs from getting on your nerves before your
really start appreciating it. This includes:

+ inhibiting the startup message
+ beginning with a blank scratch
+ no error beeping
+ sensible autosaving
+ "y" or "n" prompting

  And the packages:

+ [[https://github.com/justbur/emacs-which-key][which-key]]: a necessity for discovering the default and custom keybindings throughout this configuration
+ [[https://github.com/Wilfred/helpful][helpful]]: provides a much more useful help interface
+ [[https://github.com/editorconfig/editorconfig-emacs][editorconfig]] plugin for Emacs: to keep style definitions where they belong
+ [[https://github.com/akermu/emacs-libvterm][vterm]]: a rich terminal so I don't have to leave Emacs for my sysadmin flow

#+BEGIN_SRC emacs-lisp :tangle "./modules/base.el"

(defun c4/ux ()
  "A module for the 'base' UX."
  (setq inhibit-startup-message t) ; inhibit startup message
  (setq initial-scratch-message "") ; no scratch message
  (setq visible-bell t)             ; enable visual bell
  (global-auto-revert-mode t) ; autosave buffer on file change
  (delete-selection-mode 1) ; Selected text will be overwritten on typing
  (fset 'yes-or-no-p 'y-or-n-p) ; convert "yes" or "no" confirms to "y" and "n"

  ;; See a database of all defined keybindings
  (use-package which-key
    :init
    (setq which-key-idle-delay 0.96)
    :diminish
    :config
    (which-key-mode))

  ;; Better help documentation
  (use-package helpful
    :custom
    (counsel-describe-function-function #'helpful-callable)
    (counsel-describe-variable-function #'helpful-variable)
    :bind
    ([remap describe-function] . counsel-describe-function)
    ([remap describe-command] . helpful-command)
    ([remap describe-variable] . counsel-describe-variable)
    ([remap describe-key] . helpful-key))

  ;; Editorconfig
  (use-package editorconfig
    :diminish
    :config
    (editorconfig-mode))

  ;; Better terminal
  (use-package vterm)

  (c4/lookup))

#+END_SRC

**** ~c4/lookup~

The UX base includes a single submodule for defining valuable search and sorting functionality using
the [[https://github.com/abo-abo/swiper][ivy ecosystem]] of packages. These include:

+ swiper: incremental buffer searching
+ ivy itself: better minibuffer completion
+ counsel: provides a richer experience in Emacs interactive prompts
+ [[https://github.com/Yevgnen/ivy-rich][ivy-rich]]: provides more contextual information in the minibuffer
+ [[https://github.com/raxod502/prescient.el][ivy-prescient]]: sorts your commands by usage

#+BEGIN_SRC emacs-lisp :tangle "./modules/base.el"

(defun c4/lookup ()
  "A module for search functionality."
  ;; Incremental search
  (use-package swiper)

  ;; Lookup enhancements
  (use-package ivy
    :diminish
    :custom
    (ivy-initial-inputs-alist nil) ; no ^ before searches
    :bind
    (("C-s" . swiper)
    ("C-r" . swiper-backward)
    :map ivy-minibuffer-map
    ("TAB" . ivy-alt-done)
    ("C-l" . ivy-alt-done)
    ("C-j" . ivy-next-line)
    ("C-k" . ivy-previous-line)
    :map ivy-switch-buffer-map
    ("C-k" . ivy-previous-line)
    ("C-l" . ivy-done)
    ("C-d" . ivy-switch-buffer-kill)
    :map ivy-reverse-i-search-map
    ("C-k" . ivy-previous-line)
    ("C-d" . ivy-reverse-i-search-kill)))

  (use-package counsel
    :diminish
    :bind
    (("C-x b" . counsel-ibuffer)
    ("C-M-j" . counsel-switch-buffer)
    :map minibuffer-local-map
    ("C-x r" . 'counsel-minibuffer-history))
    :config
    (counsel-mode 1))

  (use-package ivy-rich
    :after (ivy counsel)
    :config
    (ivy-rich-mode))

  ;; Command sorting recent
  (use-package ivy-prescient
    :after counsel
    :custom
    (ivy-prescient-enable-filtering nil)
    :config
    (prescient-persist-mode 1)
    (ivy-prescient-mode 1)))

(provide 'base)
#+END_SRC

** Keybindings

C4 takes a lot of inspiration from Doom and Spacemacs for its keybindings. For one, it's [[https://github.com/emacs-evil/evil][evil to the
bone]]. Ergonomic keybindings and modal editing are good ideas that will save my hands and wrists in
the long run.

#+BEGIN_QUOTE
That said, I do have my own ideas toward that end which won't necessarily require evil-mode. They are
very much just inklings at the moment.
#+END_QUOTE

*** ~c4/keybindings~

The keybindings are exposed via a top level module. It's composed of three submodules.

#+BEGIN_SRC emacs-lisp :tangle "./modules/keybindings.el"
(defun c4/keybindings ()
  (c4/evil)
  (c4/transient)
  (c4/mnemonics))

#+END_SRC

And then it's served in our =init.el=.

#+BEGIN_SRC emacs-lisp :tangle "./init.el"

(c4/keybindings)

#+END_SRC

**** ~c4/evil~

This submodule does the necessary work of corrupting Emacs for Vim incantatations:

+ setting up evil-mode
+ [[https://github.com/emacs-evil/evil-collection][evil-collection]]: evil-mode community key presets for many popular Emacs packages

#+BEGIN_SRC emacs-lisp :tangle "./modules/keybindings.el"

(defun c4/evil ()
  (use-package evil
    :custom
    (evil-want-integration t)
    (evil-want-keybinding nil)
    (evil-want-C-u-scroll t)
    (evil-want-C-i-jump nil)
    :hook
    (emacs-startup . evil-mode)
    :config
    (define-key evil-insert-state-map (kbd "C-g") 'evil-normal-state)
    (define-key evil-insert-state-map (kbd "C-h") 'evil-delete-backward-char-and-join)

    ;; Use visual line motions even outside of visual-line-mode buffers
    (evil-global-set-key 'motion "j" 'evil-next-visual-line)
    (evil-global-set-key 'motion "k" 'evil-previous-visual-line)
    (evil-set-initial-state 'messages-buffer-mode 'normal)

    (evil-set-initial-state 'dashboard-mode 'normal))

  (use-package evil-collection
    :after evil
    :config
    (evil-collection-init)))



#+END_SRC

**** ~c4/transient~

Transient keybindings are like interactive minor modes. They set a context within which only certain
keys will perform actions. A good use case for this is text scaling.

This functionality is enabled through the [[https://github.com/abo-abo/hydra][hydra Emacs package]].

#+BEGIN_SRC emacs-lisp :tangle "./modules/keybindings.el"

(defun c4/transient ()
  (use-package hydra
    :config
    (defhydra hydra-org-src-find (:timeout 3)
      "cycle through all source blocks in the current buffer"
      ("j" org-babel-next-src-block "next")
      ("k" org-babel-previous-src-block "previous")
      ("RET" nil "exit" :exit t))

    (defhydra hydra-org-heading-find (:timeout 3)
      "cycle through all headings at the current level"
      ("j" org-forward-heading-same-level "next")
      ("k" org-backward-heading-same-level "previous")
      ("RET" nil "exit" :exit t))

    (defhydra hydra-text-scale (:timeout 4)
      "scale text"
      ("j" text-scale-increase "in")
      ("k" text-scale-decrease "out")
      ("RET" nil "exit" :exit t))))

#+END_SRC

**** ~c4/mnemonics~

Keybinding mnemonics are directly lifted from Spacemacs and Doom Emacs. The idea is to group common
actions under their own prefix based on the area of Emacs they affect.

Repeated keys indicate a default command or a contextual undo for the current domain.

Packages in use:

+ [[https://github.com/noctuid/general.el][general.el]]: a keybinding framework to lead your keys

#+BEGIN_SRC emacs-lisp :tangle "./modules/keybindings.el"

(defun c4/mnemonics ()
  (use-package general
    :after evil
    :config
    (general-evil-setup 1)
    (general-create-definer c4/leader-key-def
      :keymaps '(normal insert visual emacs)
      :prefix "SPC"
      :global-prefix [\s-SPC])

    (c4/key-def-global)
    (c4/key-def-buffer)
    (c4/key-def-config)
    (c4/key-def-file)
    (c4/key-def-help)
    (c4/key-def-org)
    (c4/key-def-project)
    (c4/key-def-session)
    (c4/key-def-toggle)
    (c4/key-def-window)))

#+END_SRC

C4 defines the following mnemonics:

Now let's break down each domain.

***** ~c4/key-def-global~ (=SPC-=)

These keybindings wrap global commands. They are unprefixed themselves.

Example: =SPC-'= opens a fresh terminal.

#+BEGIN_SRC emacs-lisp :tangle "./modules/keybindings.el"

(defun c4/key-def-global ()
  (c4/leader-key-def
    "'" '(vterm :which-key "open terminal")
    "SPC" '(universal-argument :which-key "command modifier")))

#+END_SRC

***** ~c4/key-def-buffer~ (=SPC-b=)

These keybindings wrap buffer commands. They include switching, killing, saving, and
narrowing buffers.

+ lowercase bindings affect the /current/ buffer
+ uppercase bindings affect /all/ open buffers or invert the command

#+BEGIN_SRC emacs-lisp :tangle "./modules/keybindings.el"

(defun c4/key-def-buffer ()
  (c4/leader-key-def
    "b" '(:ignore t :which-key "buffer")
    "bb" '(counsel-switch-buffer :which-key "switch")
    "bd" '(kill-current-buffer :which-key "kill")
    "bD" '(kill-some-buffers :which-key "kill multiple")
    "bn" '(:ignore t :which-key "narrow")
    "bnn" '(widen :which-key "reset")
    "bnd" '(narrow-to-defun :which-key "to defun")
    "bnp" '(narrow-to-page :which-key "to page")
    "bnr" '(narrow-to-region :which-key "to region")
    "bk" '(kill-current-buffer :which-key "kill")
    "bK" '(kill-some-buffers :which-key "kill multiple")
    "bs" '(swiper :which-key "search")
    "bS" '(swiper-backward :which-key "search backward")
    "bw" '(save-buffer :which-key "write")
    "bW" '(save-some-buffers :which-key "write modified")))

#+END_SRC

***** ~c4/key-def-config~ (=SPC-c=)

These keybindings wrap commands relevant to C4 configuration such as opening or reloading
configuration. Additionally, there are bindings for evaluating an expression, region, or defun.

#+BEGIN_SRC emacs-lisp :tangle "./modules/keybindings.el"

(defun c4/key-def-config ()
  (c4/leader-key-def
    "c" '(:ignore t :which-key "C4 config")
    "cc" '(c4/open-config :which-key "open")
    "cr" '(c4/reload-config :which-key "reload")
    "ce" '(:ignore t :which-key "eval")
    "cee" '(eval-last-sexp :which-key "S-exp")
    "ced" '(eval-defun :which-key "defun")
    "cer" '(eval-region :which-key "region")))

(defun c4/open-config ()
  "Open files in config directory."
  (interactive)
  (counsel-find-file nil user-emacs-directory))

(defun c4/reload-config ()
  "Reloads the config in place."
  (interactive)
  (load-file (concat user-emacs-directory "init.el")))

#+END_SRC

***** ~c4/key-def-file~ (=SPC-f=)

These keybindings wrap commands for file operations. Currently only includes file finding.

#+BEGIN_SRC emacs-lisp :tangle "./modules/keybindings.el"

(defun c4/key-def-file ()
  (c4/leader-key-def
    "f" '(:ignore t :which-key "file")
    "ff" '(counsel-find-file :which-key "find")))

#+END_SRC

***** ~c4/key-def-help~ (=SPC-h=)

These keybindings wrap commands for the help documentation and Emacs manual.

#+BEGIN_SRC emacs-lisp :tangle "./modules/keybindings.el"

(defun c4/key-def-help ()
  (c4/leader-key-def
    "h" '(:ignore t :which-key "help")
    "ha" '(counsel-apropos :which-key "apropos")
    "hd" '(:ignore t :which-key "describe")
    "hdd" '(counsel-describe-function :which-key "function")
    "hdf" '(counsel-describe-face :which-key "face")
    "hdc" '(helpful-command :which-key "command")
    "hdv" '(counsel-describe-variable :which-key "variable")
    "hdk" '(helpful-key :which-key "keybinding")
    "hds" '(helpful-at-point :which-key "symbol at point")
    "hm" '(:ignore t :which-key "manual")
    "hmm" '(info-emacs-manual :which-key "emacs")))

#+END_SRC

***** ~c4/key-def-org~ (=SPC-o=)

These keybindings wrap all Org-mode relevant commands.

They allow you to view your agenda, schedule dates and deadlines, evaluate source blocks and tangle,
and provide Org buffer functionality like capturing and refiling.

#+BEGIN_SRC emacs-lisp :tangle "./modules/keybindings.el"

(defun c4/key-def-org ()
  (c4/leader-key-def
    "o" '(:ignore t :which-key "org")
    "oa" '(:ignore t :which-key "agenda")
    "oaa" '(org-agenda-list :which-key "weekly")
    "oaf" '(org-agenda :which-key "full")
    "oat" '(org-set-tags-command :which-key "tags")
    "ob" '(:ignore t :which-key "buffer")
    "obb" '(org-insert-link :which-key "link")
    "obc" '(org-capture :which-key "capture")
    "obn" '(:ignore t :which-key "narrow")
    "obnn" '(org-toggle-narrow-to-subtree :which-key "subtree")
    "obnb" '(org-narrow-to-block :which-key "block")
    "obne" '(org-narrow-to-element :which-key "element")
    "obr" '(org-refile :which-key "refile")
    "obs" '(:ignore t :which-key "search")
    "obss" '(hydra-org-src-find/body :which-key "src blocks")
    "obsh" '(hydra-org-heading-find/body :which-key "headings")
    "od" '(:ignore t :which-key "date")
    "odd" '(org-deadline :which-key "deadline")
    "ods" '(org-schedule :which-key "schedule")
    "os" '(:ignore t :which-key "source")
    "ose" '(org-edit-special :which-key "edit")
    "osw" '(org-edit-src-save :which-key "save edits")
    "oss" '(org-babel-execute-src-block :which-key "execute source")
    "ost" '(org-babel-tangle :which-key "tangle")))

#+END_SRC

***** ~c4/key-def-project~ (=SPC-p=)

These keybindings wrap project-level commands.

They allow you to navigate projects, find files within them, switch between them, and provide a
powerful git interface for managing them.

The packages they rely upon:

+ [[https://github.com/bbatsov/projectile][projectile]]: a feature-rich project management package for Emacs
+ [[https://github.com/magit/magit][magit]]: probably the last git workflow you'll ever need
+ [[https://github.com/magit/forge][forge]]: superior integration with GitHub from right inside Emacs

The actual configuration for these packages is documented in the =projects.el= module generated
later in this file.

#+BEGIN_SRC emacs-lisp :tangle "./modules/keybindings.el"

(defun c4/key-def-project ()
  (c4/leader-key-def
    "p" '(:ignore t :which-key "project")
    "p'" '(projectile-run-vterm :which-key "open terminal")
    "pp" '(counsel-projectile-switch-project :which-key "switch")
    "pf" '(counsel-projectile-find-file :which-key "find file")
    "pg" '(:ignore t :which-key "git")
    "pgg" '(magit-status :which-key "status")
    "pgc" '(magit-commit :which-key "commit")
    "pgd" '(magit-diff :which-key "diff")
    "pgf" '(:ignore t :which-key "forge")
    "pgff" '(forge-pull :which-key "pull")
    "pgfF" '(forge-fork :which-key "fork repo")
    "pgfi" '(forge-list-issues :which-key "issues")
    "pgfI" '(forge-create-issue :which-key "create issue")
    "pgi" '(magit-init :which-key "init")
    "pgp" '(magit-push :which-key "push")
    "pgP" '(magit-pull :which-key "pull")
    "pgr" '(magit-remote :which-key "remote")
    "pgs" '(magit-stage :which-key "stage")
    "pgS" '(magit-stage-file :which-key "stage file")
    "ps" '(counsel-projectile-rg :which-key "search")))

#+END_SRC

***** ~c4/key-def-session~ (=SPC-q=)

These keybindings wrap commands that affect your Emacs session.

For now, it includes bindings for closing Emacs with and without saving.

#+BEGIN_SRC emacs-lisp :tangle "./modules/keybindings.el"

(defun c4/key-def-session ()
  (c4/leader-key-def
    "q" '(:ignore t :which-key "quit")
    "qq" '(save-buffers-kill-emacs :which-key "and save")
    "qQ" '(kill-emacs :which-key "really quit")))

#+END_SRC

***** ~c4/key-def-toggle~ (=SPC-t=)

These keybindings wrap interface toggles and on-the-fly UI modifications.

For now, you can change your theme and scale the text via a transient binding.

#+BEGIN_SRC emacs-lisp :tangle "./modules/keybindings.el"

(defun c4/key-def-toggle ()
  (c4/leader-key-def
    "t" '(:ignore t :which-key "toggle")
    "tt" '(counsel-load-theme :which-key "theme")
    "ts" '(hydra-text-scale/body :which-key "scale text")))

#+END_SRC

***** ~c4/key-def-window~ (=SPC-w=)

These keybindings wrap commands that affect the current window.

Windows can be split, moved, and closed when not needed.

This is the biggest shift from Vim to Emacs. In Emacs, windows are /views/. Buffers are detached
from them and are not killed when you close them. They persist in the background until called into
another window.

Their state is preserved.

#+BEGIN_QUOTE
C4 is built to prioritize Emacs as the driver of my entire desktop computing experience.

Emacs largely *is* my workstation at this point.

So these definitions also include bindings for manipulating X windows served by [[https://github.com/ch11ng/exwm][EXWM]].

If you don't need these desktop bindings, feel free to remove them along with the ~c4/desktop~
setting and regenerate the config.
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle "./modules/keybindings.el"
  (defun c4/key-def-window ()
    (c4/leader-key-def
    "w" '(:ignore t :which-key "window")
    "wc" '(evil-window-delete :which-key "close")
    "wd" '(:ignore t :which-key "desktop")
    "wdf" '(exwm-floating-toggle-floating :which-key "floating")
    "wdF" '(exwm-layout-toggle-fullscreen :which-key "fullscreen")
    "wdk" '(exwm-layout-toggle-keyboard :which-key "keyboard mode")
    "wdm" '(exwm-layout-toggle-mode-line :which-key "mode line")
    "wdM" '(exwm-layout-toggle-minibuffer :which-key "minibuffer")
    "ws" '(:ignore t :which-key "split")
    "wss" '(evil-window-split :which-key "horizontal")
    "wsS" '(evil-window-vsplit :which-key "vertical")))

  (provide 'keybindings)
#+END_SRC

** Projects

The =projects.el= module configures C4 for my Git/GitHub project workflows.

It's pretty straightforward.

It installs projectile and points it to a =path= to look for projects under version control and then
evaluates the ~c4/git~ submodule with your GitHub =username=.

#+BEGIN_SRC emacs-lisp :tangle "./modules/projects.el"
(cl-defun c4/projects (&key path username)
  (use-package projectile
    :diminish
    :config
    (projectile-mode)
    :custom
    (projectile-project-search-path (list path))
    (projectile-completion-system 'ivy)
    (projectile-switch-project-action #'projectile-dired)
    :bind-keymap
    ("C-c p" . projectile-command-map))

  (use-package counsel-projectile
    :after projectile
    :config
    (counsel-projectile-mode))
  (eval (c4/git username)))

#+END_SRC

And then in =init.el=:

#+BEGIN_SRC emacs-lisp :tangle "./init.el"

(c4/projects
  :path "~/Workbench"
  :username "cr-jr")

#+END_SRC

*** ~c4/git~

This submodule does the actual work of installing and configuring magit & forge. It also includes
[[https://github.com/dgutov/diff-hl][diff-hl]] so you can see changes to the files in your projects in the fringe.

This will make it easier to determine what changes to commit if you choose to stage hunks with magit
instead of whole files.

#+BEGIN_QUOTE
Be aware that you *will need* a GitHub account along with a personal access token to make any of this work.
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle "./modules/projects.el"

(defun c4/git (user)
  (use-package magit
    :commands (magit magit-status)
    :custom
    (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1))

  (use-package diff-hl
    :after magit
    :hook
    (after-init . global-diff-hl-mode)
    (magit-pre-refresh . diff-hl-magit-pre-refresh)
    (magit-post-refresh . diff-hl-magit-post-refresh))

  (use-package forge
    :after magit
    :custom
    (auth-sources '("~/.authinfo"))
    :config
    (ghub-request "GET" "/user" nil
      :forge 'github
      :host "api.github.com"
      :username user
      :auth 'forge)))

(provide 'projects)
#+END_SRC

** Code

The =code.el= module contains configuration and functionality for your programming needs. Right now, it
only includes basic setup and will be expanded on as I work through Emacs from Scratch.

*** ~c4/code~

This is the top-level setting for working with code. For now, it's skeletal and only provides the
[[https://github.com/Fanael/rainbow-delimiters][rainbow-delimiters]] package for all programming modes.

#+BEGIN_SRC emacs-lisp :tangle "./modules/code.el"
(defun c4/code ()
  (use-package rainbow-delimiters
    :hook (prog-mode . rainbow-delimiters-mode)))

(provide 'code)
#+END_SRC

Now, in =init.el=:

#+BEGIN_SRC emacs-lisp :tangle "./init.el"

(c4/code)

#+END_SRC

** Documents

The =documents.el= module configures settings and functionality for document modes in Emacs. Its
primary focus is [[https://orgmode.org][Org Mode]] and configuring it for technical documentation, note-taking, journaling, and
literate programming.

*** ~c4/org~

This is a top-level module exposed by =documents.el= It wraps all of the submodule Org Mode settings
under a common interface for =init.el=.

#+BEGIN_SRC emacs-lisp :tangle "./modules/documents.el"
  (cl-defun c4/org (&key path)
    (use-package org
      :straight org-plus-contrib
      :init
      (setq org-ellipsis " ↴")
      (setq org-directory path)
      (c4/org-agenda)
      (c4/org-templates)
      (c4/org-babel)
      :config
      (c4/org-theme)
      (advice-add 'org-refile :after 'org-save-all-org-buffers)
      :hook
      (org-mode . c4/org-init)))

#+END_SRC

Now, we call in it =init.el=.

#+BEGIN_SRC emacs-lisp :tangle "./init.el"

(c4/org :path "~/Org")

#+END_SRC

**** ~c4/org-init~

A submodule that defines the absolute basic settings for Org Mode whenever an Org buffer opens.

By default I want automatically indent content under Org headings, enable variable pitch so I can
use my document font, and ensure my text will wrap at the right line length.

Packages in use:

+ [[https://github.com/joostkremers/visual-fill-column][visual-fill-column]]: wraps visual line mode buffers at a given line length and provides the option
  to center the buffer

#+BEGIN_SRC emacs-lisp :tangle "./modules/documents.el"

(defun c4/org-init ()
  (org-indent-mode 1)
  (variable-pitch-mode 1)
  (visual-line-mode 1)
  (auto-fill-mode 1)

  (use-package visual-fill-column
    :defer t
    :custom
    (visual-fill-column-width 100)
    (visual-fill-column-center-text t)
    :hook (org-mode . visual-fill-column-mode)))

#+END_SRC

**** ~c4/org-theme~

A submodule that performs some UI tweaks for Org buffers. Mainly, it resets certain faces to the
code font and makes the bullets look proper.

Packages in use:

+ [[https://github.com/integral-dw/org-superstar-mode][org-superstar-mode]]: make your Org headings /fancy/

#+BEGIN_SRC emacs-lisp :tangle "./modules/documents.el"

(defun c4/org-theme ()
  (set-face-attribute 'org-block nil
    :foreground nil :inherit 'fixed-pitch)
  (set-face-attribute 'org-block-begin-line nil
    :foreground nil :weight 'normal :inherit 'fixed-pitch)
  (set-face-attribute 'org-block-end-line nil
    :foreground nil :weight 'normal :inherit 'fixed-pitch)
  (set-face-attribute 'org-checkbox nil :inherit 'fixed-pitch)
  (set-face-attribute 'org-code nil :inherit '(shadow fixed-pitch))
  (set-face-attribute 'org-table nil :inherit '(shadow fixed-pitch))
  (set-face-attribute 'org-verbatim nil :inherit '(shadow fixed-pitch))
  (set-face-attribute 'org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch))
  (set-face-attribute 'org-meta-line nil :inherit '(font-lock-comment-face fixed-pitch))

  (use-package org-superstar
    :diminish
    :after org
    :hook
    (org-mode . org-superstar-mode)
    :custom
    (org-superstar-headline-bullets-list
      '("§" "☙" "჻" " " " " " " " "))))

#+END_SRC

**** ~c4/org-agenda~

This submodule sets up the Org agenda flow for creating task lists and project planning.

#+BEGIN_SRC emacs-lisp :tangle "./modules/documents.el"

(defun c4/org-agenda ()
  (setq org-agenda-start-with-log-mode t)
  (setq org-log-done 'time)
  (setq org-log-into-drawer t)

  (setq org-agenda-files
    '("Tasks.org" "Projects.org"))

  (setq org-todo-keywords
    '((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d!)")
        (sequence
          "BACKLOG(b)" "PLAN(p)" "READY(r)" "ACTIVE(a)" "REVIEW(v)"
          "WAIT(w@/!)" "HOLD(h)" "|" "COMPLETED(c)" "CANC(k@)")))

  (setq org-refile-targets
    '(("Archive.org" :maxlevel . 1)
        ("Tasks.org" :maxlevel . 1)))

  (setq org-tag-alist
    '((:startgroup)
        ("@product" . ?P)
        ("@experiment" . ?E)
        ("@resource" . ?R)
        ("@learning" . ?L)
        ("@teaching" . ?T)
        (:endgroup)
        ("prototyping" . ?p)
        ("developing" . ?d)
        ("documenting" . ?D)
        ("testing" . ?t)
        ("refactoring" . ?r)))

  (setq org-agenda-custom-commands
    '(("d" "Dashboard"
        ((agenda "" ((org-deadline-warning-days 7)))
          (todo "NEXT"
            ((org-agenda-overriding-header "Next Tasks")))))

        ("P" "Products" tags-todo "@product")
        ("E" "Experiments" tags-todo "@experiment")
        ("R" "Resources" tags-todo "@resource")
        ("L" "Learning" tags-todo "@learning")
        ("T" "Teaching" tags-todo "@teaching")

        ("s" "Workflow Status"
          ((todo "WAIT"
            ((org-agenda-overriding-header "Waiting on External")
              (org-agenda-files org-agenda-files)))
          (todo "REVIEW"
            ((org-agenda-overriding-header "Under Review")
              (org-agenda-files org-agenda-files)))
          (todo "PLAN"
            ((org-agenda-overriding-header "Planning")
              (org-agenda-files org-agenda-files)))
          (todo "BACKLOG"
            ((org-agenda-overriding-header "Project Backlog")
              (org-agenda-files org-agenda-files)))
          (todo "READY"
            ((org-agenda-overriding-header "Ready for Work")
              (org-agenda-files org-agenda-files)))
          (todo "ACTIVE"
            ((org-agenda-overriding-header "Active Projects")
              (org-agenda-files org-agenda-files)))
          (todo "COMPLETED"
            ((org-agenda-overriding-header "Completed Projects")
              (org-agenda-files org-agenda-files)))
          (todo "CANC"
            ((org-agenda-overriding-header "Cancelled Projects")
              (org-agenda-files org-agenda-files))))))))

#+END_SRC

**** ~c4/org-templates~

This submodule sets up Org capture templates for scaffolding a new task and other TBD templating
needs.

#+BEGIN_SRC emacs-lisp :tangle "./modules/documents.el"

(defun c4/org-templates ()
  (setq org-capture-templates
    `(("t" "Tasks / Projects")
        ("tt" "Task" entry (file+olp "Tasks.org" "Inbox")
          "* TODO %?\n %U\n %a\n %i" :empty-lines 1))))

#+END_SRC

**** ~c4/org-babel~

This submodule configures source block tangling and execution. It also defines the languages to
allow for a literate programming workflow.

#+BEGIN_SRC emacs-lisp :tangle "./modules/documents.el"

(defun c4/org-babel ()
  (org-babel-do-load-languages
    'org-babel-load-languages
    '((emacs-lisp . t)
      (js . t)))

  (setq org-src-fontify-natively t)
  (setq org-confirm-babel-evaluate nil))


(provide 'documents)
#+END_SRC

** Desktop

As I stated earlier, Emacs is the driver of my desktop computing experience.

Therefore, the final piece in my Emacs configuration is EXWM. Using Emacs as my window manager
brings several advantages:

+ A unified desktop interface
+ Less context switching
+ A window manager as flexible and extensible as Emacs itself
+ Enforced focus on my work environment

I'm aware this approach isn't for everyone, and I wouldn't use it myself if I didn't trust the
stability of Emacs as software. If you have trepidations, you can disable the entire desktop module
and everything else will still work.

#+BEGIN_QUOTE
EXWM only works on Linux systems, though.
#+END_QUOTE

*** Setup

To actually use Emacs as my desktop environment, I need to create a =.xinitrc=.

#+BEGIN_SRC sh :tangle "~/.xinitrc"
# Caps to CTRL
setxkbmap -option ctrl:nocaps

# Disable touchpad
xinput set-prop 12 "Device Enabled" 0

# Default cursor
xsetroot -cursor_name left_ptr

# Xresources
xrdb ~/.Xresources

# Settings
gnome-settings-daemon &

# Autostart programs
dex -a

# Removable media
udiskie &

# Notifications
dunst &

# Start EXWM
exec dbus-launch --exit-with-session emacs -mm --debug-init
#+END_SRC

I also used software (ARandR) to configure my multi-monitor setup.

#+BEGIN_SRC sh :tangle "./desktop/multihead.sh"
#!/bin/sh
xrandr --output LVDS --primary --mode 1366x768 --pos 241x1080 --rotate normal --output VGA-0 --off --output HDMI-0 --mode 1920x1080 --pos 0x0 --rotate normal
#+END_SRC

*** ~c4/desktop~

This is the top level module that =desktop.el= exposes. It wraps all the desktop definition
submodules that are documented below.

#+BEGIN_SRC emacs-lisp :tangle "./modules/desktop.el"
    (defun c4/desktop ()
      "A module for my EXWM configuration."
      (use-package exwm
        :if window-system
        :diminish
        :config
        ;; Startup process
        (start-process-shell-command
          "nitrogen" nil "nitrogen --restore")

        (display-time-mode t)

        (setq exwm-workspace-number 6)
        (setq display-time-default-load-average nil)
        (setq exwm-workspace-warp-cursor t)
        (setq focus-follows-mouse t)

        (setq exwm-input-prefix-keys
              '(?\C-x
                ?\C-u
                ?\C-h
                ?\M-x
                ?\M-`
                ?\M-&
                ?\M-:
                ?\s-\ ))

        (setq exwm-input-global-keys
              `(([?\s-K] . windmove-swap-states-up)
                ([?\s-k] . windmove-up)
                ([?\s-L] . windmove-swap-states-right)
                ([?\s-l] . windmove-right)
                ([?\s-J] . windmove-swap-states-down)
                ([?\s-j] . windmove-down)
                ([?\s-H] . windmove-swap-states-left)
                ([?\s-h] . windmove-left)
                ([?\s-r] . exwm-reset)
                ([?\s-Q] . exwm-exit)
                ([?\s-q] . exwm-restart)
                ([?\s-W] . exwm-workspace-swap)
                ([?\s-w] . exwm-workspace-switch)
                ([?\s-D] . counsel-linux-app)
                ([?\s-d] . (lambda (cmd)
                              (interactive (list (read-shell-command "$ ")))
                              (start-process-shell-command cmd nil cmd)))
                ,@(mapcar (lambda (i)
                            `(,(kbd (format "s-%d" i)) .
                              (lambda ()
                                (interactive)
                                (exwm-workspace-switch-create ,i))))
                          (number-sequence 0 9))))

        (define-key exwm-mode-map [?\C-q] 'exwm-input-send-next-key)

        ;; Update window class with the buffer name
        (add-hook 'exwm-update-class-hook #'c4/exwm-update-class)

        (require 'exwm-randr)
        (setq exwm-randr-workspace-monitor-plist
              '(0 "LVDS" 2 "LVDS" 4 "LVDS" 1 "HDMI-0" 3 "HDMI-0" 5 "HDMI-0"))
        (start-process-shell-command "xrandr" nil
                                      (concat user-emacs-directory "desktop/multihead.sh"))
        (exwm-randr-enable)

        (require 'exwm-systemtray)
        (setq exwm-systemtray-height 16)
        (exwm-systemtray-enable)

        (exwm-enable))

      ;; EXWM: Desktop Environment
      (use-package desktop-environment
        :after exwm
        :diminish
        :bind
        ("s-l" . windmove-right)
        :config
        (desktop-environment-mode)))

    (defun c4/exwm-update-class ()
      (exwm-workspace-rename-buffer exwm-class-name))

  (provide 'desktop)
#+END_SRC

Finally, we add it to =init.el=.

#+BEGIN_SRC emacs-lisp :tangle "./init.el"

(c4/desktop)
#+END_SRC
