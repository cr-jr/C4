#+TITLE: C4 Configuration
#+DATE: 2021-01-31
#+AUTHOR: Chatman R. Jr
:PROPERTIES:
:header-args: :mkdirp yes
:header-args:emacs-lisp: :tangle "./C4.el"
:END:

* Summary

This configuration is my personal configuration/sandbox that grows as I use my favorite productivity
environment and learn how to do more with it.

C4 prioritizes ease, convenience and performance. A clean, minimal UI is what I love.

This is an Org-driven configuration consisting of this file (=C4.org=), the generated =C4.el= and
the =init.el= that loads it on startup.

If something doesn't add value to my workflow, it simply isn't here.

Custom variables and procedures in this config are always prefixed with =C4=.

* Initialization
** Package Management

C4 requires [[https://github.com/raxod502/straight.el][straight.el]] and [[https://github.com/jwiegley/use-package][use-package]], so that gets loaded in first.

#+BEGIN_SRC emacs-lisp
  ;;; Setup straight.el with use-package
  (setq straight-repository-branch "develop")
  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))

  ;; use-package integration
  (straight-use-package 'use-package)
  (setq straight-use-package-by-default t)

#+END_SRC

** Building the Configuration

After package setup, we need to load in [[https://orgmode.org][Org Mode]] to build the configuration as well as attach a hook
to rebuild it on save.

#+BEGIN_SRC emacs-lisp

  ;;; Need Org Mode to be first package installed because it builds the config.
  (use-package org
    :straight org-plus-contrib)

  ;; Generate C4.el from the source blocks in C4.org
  (defun C4/load ()
    (org-babel-tangle-file
     (concat user-emacs-directory "C4.org")
     (concat user-emacs-directory "C4.el")))

  ;; Always generate on load
  (C4/load)

  ;; Setup a hook to re-tangle the config on modification.
  (add-hook 'org-mode-hook
            (lambda () (add-hook 'after-save-hook #'C4/load)))

#+END_SRC

** Startup Performance
*** Garbage collection

The first optimization involves increasing the Emacs garbage collection threshold to =100MB= on
startup. This gives a slight boost in initialization. After Emacs starts up, we use a hook to reduce
the threshold back to its approximate initial state.

#+BEGIN_SRC emacs-lisp

  ;; Raise the garbage collection threshold high as emacs starts
  (setq gc-cons-threshold 100000000)
  (setq read-process-output-max (* 1024 1024))

  ;; Drop it down once loaded
  (add-hook 'after-init-hook #'(lambda () (setq gc-cons-threshold 1000000)))

#+END_SRC

** Housekeeping

Now I want to do some decluttering. Emacs has a way of operating with files that can leave a lot of
crap behind in my filesystem, so I needed to do a little cleanup and ordering of where and if it
generates temporary files and directories.

*** Inhibit lockfiles and custom files

My experience with lockfiles is that they add a lot of noise to my directories and projects, so I'm
just going to disable them entirely. The same goes for custom files, because I prefer to do all of
my customizations with Emacs Lisp.

#+BEGIN_SRC emacs-lisp

  ;; Lockfiles do more harm than good
  (setq create-lockfiles nil)

  ;; Custom files just add clutter
  (setq custom-file null-device)

#+END_SRC

*** no-littering

no-littering is a great package that ensures files and directories generated by Emacs or its
packages are allocated to their proper places. The killer feature is how it allows you to set a
central directory for all autosaved files.

#+BEGIN_SRC emacs-lisp

  ;; Put temporary and data files in proper locations
  (use-package no-littering
    :custom
    (auto-save-file-name-transforms
     `((".*" ,(no-littering-expand-var-file-name "auto-save/") t))))

#+END_SRC

*** Create parent directories automatically

One great thing about Emacs is that I can manage my ideas and work as they come. I streamline this
by telling Emacs to automatically create directories that don't exist for new files. This allows me
to build the file structure for my projects on the fly.

#+BEGIN_SRC emacs-lisp

  ;; Create parent dirs when opening new files
   (add-to-list 'find-file-not-found-functions #'C4/create-parent)

  (defun C4/create-parent ()
    "Ensures that the parent dirs are created for a nonexistent file."
    (let ((parent-directory (file-name-directory buffer-file-name)))
      (when (and (not (file-exists-p parent-directory))
                 (y-or-n-p (format
                            "Directory `%s' does not exist! Create it?"
                            parent-directory)))
        (make-directory parent-directory t))))

#+END_SRC

*** whitespace-cleanup-mode

whitespace-cleanup-mode is a package that intelligently checks files for errant whitespace and
cleans it up before saving. By default, C4 enables this behavior globally.

Some modes can be set to disable this behavior as exceptions.

#+BEGIN_SRC emacs-lisp

  ;;; Clean up whitespace in all major modes on save
  (use-package whitespace-cleanup-mode
    :config
    (global-whitespace-cleanup-mode t))

#+END_SRC

** Debugging the Configuration

When things break, I need ways of figuring out the problem. And without measurements, I can't make
improvements.

*** esup

ESUP (Emacs Start Up Profiler) is an invaluable package for benchmarking how quickly Emacs loads. My
aim: make C4 feature complete for my needs while also loading fast enough for my slightly older laptop.

#+BEGIN_SRC emacs-lisp

  ;;; Benchmark Emacs startup to debug performance
  (use-package esup)

#+END_SRC

*** elisp-bug-hunter

elisp-bug-hunter is a package that allows me to track down and eliminate bugs in C4 that might be
hiding in the tall grass.

#+BEGIN_SRC emacs-lisp

  ;;; Debug init file errors
  (use-package bug-hunter)

#+END_SRC

*** explain-pause-mode

explain-pause-mode is like =top= (more accurately =htop=) for Emacs. It allows you see all recently
run operations and discover which ones are making Emacs lag. This ensures tight performance carries
over for more than just startup times.

#+BEGIN_SRC emacs-lisp

  ;;; Check running processes in Emacs for slowdowns
  (use-package explain-pause-mode
    :config
    (explain-pause-mode))

#+END_SRC
* Utilities
** crux

This configuration includes the crux package. It's way too useful not to use. Especially since I
opted out of Vim emulation.

#+BEGIN_SRC emacs-lisp

  (use-package crux
    :hook
    (find-file . crux-reopen-as-root-mode))

#+END_SRC

* Defaults

I start working out the look and feel of my workspace as well as establish some global settings.

#+BEGIN_SRC emacs-lisp

  (setq-default cursor-type 'bar) ; default cursor as bar
  (setq-default frame-title-format '("%b")) ; window title is the buffer name

  (setq linum-format "%4d ") ; line number format
  (column-number-mode 1) ; set column number display
  (show-paren-mode 1) ; show closing parens by default

  (menu-bar-mode -1) ; disable the menubar
  (scroll-bar-mode -1) ; disable visible scroll bar
  (tool-bar-mode -1) ; disable toolbar
  (tooltip-mode -1) ; disable tooltips
  (set-fringe-mode 8) ; allow some space

  (setq inhibit-startup-message t) ; inhibit startup message
  (setq initial-scratch-message "") ; no scratch message
  (setq initial-major-mode 'text-mode)
  (setq visible-bell t)             ; enable visual bell
  (global-auto-revert-mode t) ; autosave buffer on file change
  (delete-selection-mode 1) ; Selected text will be overwritten on typing
  (fset 'yes-or-no-p 'y-or-n-p) ; convert "yes" or "no" confirms to "y" and "n"

  ;; Show line numbers in programming modes
  (add-hook 'prog-mode-hook
            (if (and (fboundp 'display-line-numbers-mode) (display-graphic-p))
                #'display-line-numbers-mode
              #'linum-mode))


  ;; Disable for document and terminal modes
  (dolist (mode '(
      org-mode-hook
      term-mode-hook
      shell-mode-hook
      treemacs-mode-hook
      vterm-mode
      eshell-mode-hook))
    (add-hook mode (lambda () (display-line-numbers-mode 0))))

  ;; Make some icons available
  (use-package all-the-icons)

#+END_SRC

** User Identity

#+BEGIN_SRC emacs-lisp

  ;;; Set full name and email address
  (setq user-full-name "Chatman R. Jr")
  (setq user-mail-address "crjr.code@protonmail.com")

#+END_SRC

** Undo/Redo

This section documents necessary packages to improve how Emacs handles undo and redo actions.

*** undo-fu

Undo-fu is a much lighter package in comparison with undo-tree. It makes undo actions much more
sensible and provides an essential redo function. Pairing it with undo-fu-session allows me to keep
a history of editing actions performed on a file through its whole existence.

#+BEGIN_SRC emacs-lisp

  ;;; Better undo/redo
  (use-package undo-fu)

  ;; Undo persistence
  (use-package undo-fu-session
    :hook
    (prog-mode . undo-fu-session-mode)
    (text-mode . undo-fu-session-mode)
    (org-mode . undo-fu-session-mode))

#+END_SRC

** Text Manipulation

It's time to setup some great packages that make text manipulation in Emacs less painful.

*** expand-region

This is a package that expands marked regions by semantic units.

#+BEGIN_SRC emacs-lisp

  ;;; Expand region selections by semantic units
  (use-package expand-region)

#+END_SRC

*** multiple-cursors

A staple package that allows multiple cursors. The rectangle mark functionality seems a little
finicky, and multiple insertion is the main reason I use it.

#+BEGIN_SRC emacs-lisp

  ;;; Multiple cursors in Emacs
  (use-package multiple-cursors)

#+END_SRC

** Search and Lookup

This section documents a special category of enhancements for finding and jumping to things in
Emacs. Popular packages to set this up include the ivy and helm ecosystems, but I decided to look at
some of the lighter, newer packages that augment built-in functionality instead.

*** selectrum

Selectrum is an Ido, Icomplete drop in enhancement. It provides basic, clean minibuffer completion
on its own, but its powers are boosted by the remaining packages.

#+BEGIN_SRC emacs-lisp

  ;;; Better minibuffer completion
  (use-package selectrum
    :config
    (selectrum-mode 1))

#+END_SRC

*** prescient

Prescient builds a store of my most used commands and queries and places them first. So I
have quick access to candidates for keybindings.

#+BEGIN_SRC emacs-lisp

  ;;; Remember frequently used commands and queries
  (use-package selectrum-prescient
    :after selectrum
    :config
    (selectrum-prescient-mode 1)
    (prescient-persist-mode 1))

#+END_SRC

*** orderless

Orderless allows you to enter your minibuffer queries as partial characters or strings. This means I
don't have to know the whole, proper name of something to find it in Emacs.

#+BEGIN_SRC emacs-lisp

  ;;; Partial completion queries support
  (use-package orderless
    :init
    (icomplete-mode)
    :custom
    (completion-styles '(orderless)))

 #+END_SRC

*** consult

#+BEGIN_SRC emacs-lisp

  ;;; Better search utilities
  (use-package consult
    :init
    (defun find-fd (&optional dir initial)
      (interactive "P")
      (let ((consult-find-command "fd --color=never --full-path ARG OPTS"))
        (consult-find dir initial)))
    (advice-add #'register-preview :override #'consult-register-window)
    :custom
    (register-preview-delay 0)
    (register-preview-function #'consult-register-window)
    (consult-narrow-key "<"))

#+END_SRC

*** embark

Embark provides an interface for performing actions in minibuffers. I'm not doing much with it yet,
but it's still there when I do need it.

#+BEGIN_SRC emacs-lisp

  ;;; An interface for minibuffer actions
  (use-package embark-consult
    :after (embark consult)
    :demand t
    :hook
    (embark-collect-mode . embark-consult-preview-minor-mode))

#+END_SRC

*** marginalia

Marginalia is a consult enhancement package that includes useful supplemental information in lookup
operations. For example: showing the docstring for interactive commands or the current styling of a face.

#+BEGIN_SRC emacs-lisp

  ;;; Adds annotations to minibuffer interfaces
  (use-package marginalia
    :after consult
    :init
    (marginalia-mode)
    (advice-add #'marginalia-cycle :after
                (lambda () (when (bound-and-true-p selectrum-mode)
                             (selectrum-exhibit))))
    (setq marginalia-annotators
          '(marginalia-annotators-heavy marginalia-annotators-light)))

#+END_SRC

*** ctrlf

I love this package.

CTRLF allows me to find anything—and I mean anything in a buffer. Most describe it as a drop-in
Swiper replacement, but it's much more than that.

For one, I like how it doesn't populate the query results with false positives. I also like how it
doesn't assume I need to see /all/ the query results right away. I can jump through them and keep
narrowing the search until there's only one result: the correct one.

#+BEGIN_SRC emacs-lisp

  ;;; Incremental search interface similar to web browsers
  (use-package ctrlf
        :config
        (ctrlf-mode 1))

#+END_SRC
** Enhancements

Now I'll add some improvements to my baseline experience.

*** smart-mode-line

smart-mode-line is the lightest mode line package I have used so far. It's perfect for me, because I
really have no need for anything but basic information about the buffer and slight customizations.

#+BEGIN_SRC emacs-lisp

  (use-package smart-mode-line
    :init
    (setq sml/theme 'light)
    (setq sml/no-confirm-load-theme t)
    (setq sml/name-width '(16 . 32))
    (setq sml/mode-width 'full)
    (setq rm-blacklist nil)
    (setq rm-whitelist '("↑"))
    :config
    (sml/setup)
    (add-to-list 'sml/replacer-regexp-list '("^~/.config/emacs/" ":Emacs:") t)
    (add-to-list 'sml/replacer-regexp-list '("^~/Workbench/" ":Code:") t)
    (add-to-list 'sml/replacer-regexp-list '("^~/Org/" ":Org:") t))

#+END_SRC

*** helpful

Helpful provides better help documentation for the many description functions in Emacs. It also
includes its own extremely /helpful/ utilities like checking a symbol at its point.

#+BEGIN_SRC emacs-lisp

  ;;; Help documentation enhancement
  (use-package helpful)

#+END_SRC

*** editorconfig

Editorconfig is a utility that normalizes basic syntax considerations for file types across editors. It ensures
you only have to maintain one file to have a solid base for editing plain text and programming source
languages.

First, install the plugin for Emacs.

#+BEGIN_SRC emacs-lisp

  ;;; Universal editor settings
  (use-package editorconfig
    :config
    (editorconfig-mode 1))

#+END_SRC

Then set some basic options. These are the ones I use:

#+BEGIN_SRC editorconfig-conf :tangle "~/.editorconfig"
  # Environment-wide editorconfig
  root = true

  [*]
  charset = utf-8
  indent_style = space
  indent_size = 2
  max_line_length = 80
  insert_final_newline = true
  trim_trailing_whitespace = true

  [*.md]
  trim_trailing_whitespace = false

  [*.{cmd,bat}]
  end_of_line = crlf

  [*.sh]
  end_of_line = lf

  # Documents
  [*.{md,markdown,org}]
  max_line_length = 100
#+END_SRC

*** vterm

The vterm package provide libvterm emulation to Emacs. This means that terminals opened in Emacs
will mirror my actual shell configuration.

I could use a lighter terminal enhancement package, but since Emacs is also my window manager, it
makes sense to have a rich terminal package instead of opening an external terminal emulator.

#+BEGIN_SRC emacs-lisp

  ;;; Rich terminal experience
  (use-package vterm)

#+END_SRC

** Faces

Faces in Emacs allow you to change how it looks. In fact, an Emacs theme is simply a user-defined
package of face customizations.

*** Typography

The typography of C4 is entirely based on Input. I use an assortment of weights, styles, and widths
to get exactly the effect I want.

#+BEGIN_SRC emacs-lisp

  ;;; Set some variables for my settings and styles
  (setq C4/font "Input Sans-13")
  (setq C4/font-bold "Input Sans Condensed-13:normal")
  (setq C4/font-italic "Input Serif Condensed-13:light:italic")

  (setq C4/document-font "Input Serif-13")
  (setq C4/terminal-font "Input Mono-13")

  ;;; By default, use Input Sans family at 13px
  (set-face-attribute 'default nil :font C4/font)
  (set-face-attribute 'bold nil :font C4/font-bold)
  (set-face-attribute 'italic nil :font C4/font-italic)
  (set-face-attribute 'bold-italic nil :inherit 'bold)

  ;;; Code font is the same as UI font
  (set-face-attribute 'fixed-pitch nil :font C4/font)

  ;;; Set default document font as Input Serif family at 13px
  (set-face-attribute 'variable-pitch nil :font C4/document-font)

  ;;; Set default terminal font as Input Mono family at 13px
  (set-face-attribute 'term nil :font C4/terminal-font)

  ;;; Some Org Mode adjustments
  (set-face-attribute 'org-document-title nil :weight 'bold :inherit 'fixed-pitch)
  (set-face-attribute 'org-document-info nil :inherit 'org-document-title)

  (set-face-attribute 'org-level-1 nil :height 1.8 :weight 'bold :inherit 'fixed-pitch)
  (set-face-attribute 'org-level-2 nil :height 1.6 :inherit 'fixed-pitch)
  (set-face-attribute 'org-level-3 nil :height 1.4 :inherit 'fixed-pitch)
  (set-face-attribute 'org-level-4 nil :height 1.2 :inherit 'fixed-pitch)
  (set-face-attribute 'org-level-5 nil :height 1.0 :inherit 'fixed-pitch)
  (set-face-attribute 'org-level-6 nil :height 0.8 :inherit 'fixed-pitch)

  (set-face-attribute 'org-code nil :inherit '(shadow fixed-pitch))
  (set-face-attribute 'org-verbatim nil :inherit '(shadow fixed-pitch))
  (set-face-attribute 'org-block nil :inherit 'fixed-pitch)
  (set-face-attribute 'org-block-begin-line nil :weight 'normal :inherit '(shadow fixed-pitch))
  (set-face-attribute 'org-block-end-line nil :weight 'normal :inherit '(shadow fixed-pitch))
  (set-face-attribute 'org-property-value nil :inherit 'fixed-pitch)
  (set-face-attribute 'org-table nil :inherit 'fixed-pitch)
  (set-face-attribute 'org-document-info-keyword nil :weight 'bold :inherit '(fixed-pitch font-lock-keyword-face))
  (set-face-attribute 'org-drawer nil :inherit 'org-document-info-keyword)
  (set-face-attribute 'org-special-keyword nil :inherit 'org-document-info-keyword)

#+END_SRC

*** UI

I also make some adjustments to the UI faces. Mainly to clean it up.

#+BEGIN_SRC emacs-lisp

  ;;; Disable the fringe background
  (set-face-attribute 'fringe nil
                      :background nil)

#+END_SRC
** Theme

C4 includes the minimal-theme collection by default to promote a clean interface and just enough
syntax highlighting.

#+BEGIN_SRC emacs-lisp

  ;;; Include and load minimal-theme collection
  (use-package minimal-theme)

  ;; Light theme loaded and enabled by default
  (load-theme 'minimal-light t)

  ;; Dark variants load but not wait for toggling
  (load-theme 'minimal t t)
  (load-theme 'minimal-black t t)

#+END_SRC

* Keybindings

This configuration sets up keybindings immediately after initialization, because it uses a non-evil
modal setup that responds to modes in context.

It does this by using:

+ modalka to enable a global command mode
+ hydra for definining transient mode states for complex operations
+ general.el unites the definition interface for the global and mnemonic keybindings
+ which-key allows keybinding discoverability

** Rationale

Emacs is slowly pushing me to think less like a Vimmer, and because of this, evil-mode feels limiting.

I'm beginning to understand that major and minor modes *are already contextual* and it makes the
most sense to define keybindings in Emacs according to which modes are /active/ in a buffer rather
than by toggling arbitrary states.

** Making bindings discoverable

which-key provides an interface for discovering keybindings in Emacs. Both built-in and user
defined. It's absolutely essential since I'm building an entirely custom modal setup and can't keep
it all in my head.

#+BEGIN_SRC emacs-lisp

  ;;; Setup which-key for keybinding discoverability
  (use-package which-key
    :custom
    (which-key-idle-delay 1.5)
    :config
    (which-key-mode))

#+END_SRC

** Command Mode

Command Mode is a global modal state for quickly issuing commands to Emacs via a set of mnemonic conventions.

#+BEGIN_QUOTE
If you're not using EXWM, make sure you remove that last hook.
#+END_QUOTE

*** Initialization

#+BEGIN_SRC emacs-lisp

  ;;; Command mode initialization
  (use-package modalka
    :commands modalka-mode
    :hook
    (text-mode . modalka-mode)
    (prog-mode . modalka-mode)
    (exwm-mode . modalka-mode))

#+END_SRC

*** Setup

#+BEGIN_SRC emacs-lisp

  ;;; Command mode setup
  (use-package general
    :config

    ;; Unbind C-SPC and rebind it to toggle Command Mode
    (global-unset-key (kbd "C-SPC"))
    (general-def "C-SPC" 'modalka-mode)

    ;; Also unbind <menu> and rebind it as a toggle
    (global-unset-key (kbd "<menu>"))
    (general-def "<menu>" 'modalka-mode)

    ;; Create a global definitiion key for actions
    (general-create-definer C4/action-key-def
      :keymaps 'modalka-mode-map)

    ;; Create a global definition key for commands
    (general-create-definer C4/command-key-def
      :keymaps 'modalka-mode-map
      :prefix "SPC"
      :global-prefix [\s-SPC]))

  ;;; Setup transient mode-ish states
  (use-package hydra)

#+END_SRC

*** Actions

Actions are low level commands. These include moving around the buffer, toggling command mode,
undo/redo motions and more.

**** Exiting Command Mode

Command Mode has a few simple escape hatches for when I'm ready to enter some text:

+ =SPC SPC= and =q= to insert at point
+ =<return>= to insert a new line below point
+ =<C-return>= to insert a new line above point

#+BEGIN_SRC emacs-lisp

  ;;; Actions: insertion
  (C4/action-key-def
    "q" '(modalka-mode :wk "insert at point")
    "<return>" '(C4/newline :wk "insert new line")
    "<C-return>" '(C4/newline-above :wk "insert new line above"))

  (defun C4/newline ()
    "Insert a newline after point"
    (interactive)
    (crux-smart-open-line nil)
    (modalka-mode 0))

  (defun C4/newline-above ()
    "Insert a newline before point"
    (interactive)
    (crux-smart-open-line-above)
    (modalka-mode 0))

  (C4/command-key-def
    "SPC" '(modalka-mode :wk "insert at point"))

#+END_SRC

**** Modifiers

I set two kinds of action modifiers: numeric and procedural.

+ Numeric action modifiers: repeat an action =n= times (ex: =4 i= will move the point 4 lines up)
+ Procedural action modifier: repeat last action explicitly (ex: =4 i .= will move the point 8 lines up)

#+BEGIN_QUOTE
Note: giving a numeric modifier to the procedural modifier will give the repeated action a /new/
numeric modifier. This is the expected Emacs behavior for =digit-argument=.
#+END_QUOTE

#+BEGIN_SRC emacs-lisp

  ;;; Actions: numeric modifiers
  (modalka-define-kbd "-" "C--")
  (modalka-define-kbd "1" "C-1")
  (modalka-define-kbd "2" "C-2")
  (modalka-define-kbd "3" "C-3")
  (modalka-define-kbd "4" "C-4")
  (modalka-define-kbd "5" "C-5")
  (modalka-define-kbd "6" "C-6")
  (modalka-define-kbd "7" "C-7")
  (modalka-define-kbd "8" "C-8")
  (modalka-define-kbd "9" "C-9")
  (modalka-define-kbd "0" "C-0")

  ;;; Actions: procedural modifier
  (C4/action-key-def
    "." '(repeat :wk "repeat last action"))

#+END_SRC

**** Movement

These actions help me get around the buffer quickly. They're somewhat modeled after Xah Fly Keys but
use modifiers to change the scope of the action. So I can use the same four keys to hop around.

#+BEGIN_SRC emacs-lisp

  ;;; Actions: movement
  (C4/action-key-def
    "i" '(previous-logical-line :wk "previous line")
    "I" '(scroll-down-command :wk "scroll up the buffer")
    "C-i" '(beginning-of-buffer :wk "jump point to beginning of buffer")
    "k" '(next-logical-line :wk "next line")
    "K" '(scroll-up-command :wk "scroll down the buffer")
    "C-k" '(end-of-buffer :wk "jump point to end of buffer")
    "j" '(backward-char :wk "previous char")
    "J" '(backward-word :wk "jump point to previous word")
    "C-j" '(beginning-of-line-text :wk "jump point to beginning text of line")
    "M-j" '(beginning-of-line :wk "jump point to beginning of line")
    "l" '(forward-char :wk "next char")
    "L" '(forward-word :wk "jump point to next word")
    "C-l" '(end-of-line :wk "jump point to end of line")
    "M-l" '(end-of-line :wk "jump point to end of line"))
#+END_SRC

**** Undo/redo

Undo/redo is an essential action so I don't shoot myself in the foot. The actions use undo-fu under
the hood.

#+BEGIN_SRC emacs-lisp

  ;;; Actions: undo/redo
  (C4/action-key-def
    "z" '(undo-fu-only-undo :wk "undo last edit")
    "Z" '(undo-fu-only-redo :wk "redo last edit")
    "C-z" '(undo-fu-only-redo-all :wk "restore edits to most recent state"))

#+END_SRC

**** Text manipulation

Next, I'm defining some actions for text manipulation. These use either native Emacs functionality
or commands provided by those packages in the equivalent section above.

***** Marking/selecting

These actions are mapped to marking regions and text selection.

#+BEGIN_SRC emacs-lisp

  ;;; Actions: marking/selecting text
  (C4/action-key-def
    "m" '(set-mark-command :wk "set a mark at point")
    "M m" '(er/expand-region :wk "cycle semantics")
    "M w" '(mark-word :wk "mark word")
    "M s" '(er/mark-sentence :wk "mark sentence")
    "M l" '(C4/mark-line :wk "mark whole line")
    "M p" '(mark-paragraph :wk "mark paragraph")
    "M [" '(er/mark-inside-pairs :wk "mark between delimiters")
    "M {" '(er/mark-outside-pairs :wk "mark around delimiters")
    "M '" '(er/mark-inside-quotes :wk "mark between quotes")
    "M \"" '(er/mark-outside-quotes :wk "mark around quotes")
    "M b" '(er/mark-org-code-block :wk "mark org code block"))

  (defun C4/mark-line ()
    "Mark the entire line"
    (interactive)
    (end-of-line)
    (set-mark-command nil)
    (beginning-of-line))

#+END_SRC

***** Killing/cutting

Now, some actions for killing and cutting text.

#+BEGIN_SRC emacs-lisp

  ;;; Actions: killing/cutting text
  (C4/action-key-def
    "x" '(kill-region :wk "cut selection")
    "X" '(clipboard-kill-region :wk "cut selection (system)"))

#+END_SRC

***** Copy/paste

Some actions for copying and pasting text.

#+BEGIN_SRC emacs-lisp

  ;;; Actions: copy/paste
  (C4/action-key-def
    "c" '(kill-ring-save :wk "copy selection")
    "C" '(clipboard-kill-ring-save :wk "copy selection (system)")
    "v" '(yank :wk "paste")
    "V" '(clipboard-yank :wk "paste (system)")
    "C-v" '(consult-yank :wk "paste from registry"))

#+END_SRC

***** Deletion

Finally, some actions for deleting text. This is the final manipulation. Deleted text will
/not/ be saved to the kill ring or anywhere else. It's gone.

Also, following the conventions of other actions, =D= is a modifier that opens other actions
for deletion. In this case, it begins deletion chords.

#+BEGIN_SRC emacs-lisp

  ;;; Actions: deleting text
  (C4/action-key-def
    "d" '(delete-char :wk "delete char after point")
    "D d" '(backward-delete-char :wk "delete char before point")
    "D r" '(delete-region :wk "delete region"))

#+END_SRC

*** Commands

The C4 command keybindings all share =SPC= as a prefix and =s-SPC= to issue these keybindings
globally (as in X applications when using EXWM).

I create a few global commands and then the rest are encapsulated in domains of influence.

Some of the commands will trigger a transient state with its own local keybindings.

Now, the global commands:

#+BEGIN_SRC emacs-lisp

  (C4/command-key-def
    "'" '(vterm :wk "open terminal from current dir"))

#+END_SRC

Now we can open a terminal from anywhere, prefix our mnemonic commands to modify them, and
immediately quit an errant keystroke.

**** Buffer (=b=)

This domain wraps all commands that affect buffers Lowercase bindings affect only the current
buffer, uppercase bindings affect /all/ active buffers or modify a buffer-local command.

#+BEGIN_SRC emacs-lisp

  (C4/command-key-def
    "b" '(:ignore t :wk "buffer")
    "bb" '(consult-buffer :wk "switch")
    "bB" '(consult-buffer-other-window :wk "switch other window")
    "bd" '(kill-current-buffer :wk "kill")
    "bD" '(kill-some-buffers :wk "kill multiple")
    "bn" '(:ignore t :wk "narrow")
    "bnn" '(widen :wk "reset")
    "bnd" '(narrow-to-defun :wk "to defun")
    "bnp" '(narrow-to-page :wk "to page")
    "bnr" '(narrow-to-region :wk "to region")
    "bk" '(kill-current-buffer :wk "kill")
    "bK" '(kill-some-buffers :wk "kill multiple")
    "bs" '(:ignore t :wk "search")
    "bss" '(ctrlf-forward-literal :wk "forward literal")
    "bsS" '(ctrlf-backward-literal :wk "backward literal")
    "bsf" '(ctrlf-forward-fuzzy :wk "forward fuzzy")
    "bsF" '(ctrlf-backward-fuzzy :wk "backward fuzzy")
    "bsr" '(ctrlf-forward-regexp :wk "forward regexp")
    "bsR" '(ctrlf-backward-regexp :wk "backward regexp")
    "bw" '(save-buffer :wk "write")
    "bW" '(save-some-buffers :wk "write modified"))

#+END_SRC

**** Config (=c=)

This domain wraps all commands that make it easier to work with my configuration itself. This
includes quickly opening my config, debugging, and reloading my config.

In addition, I define bindings that make it easier to evaluate expressions, defuns and regions in
place as I try out new settings.

#+BEGIN_SRC emacs-lisp

  (C4/command-key-def
   "c" '(:ignore t :wk "C4 config")
   "cc" '(C4/open-config :wk "open")
   "cd" '(:ignore t :wk "debug")
   "cdd" '(C4/esup-init :wk "startup")
   "cde" '(C4/bug-hunter-init :wk "errors")
   "cdp" '(explain-pause-top :wk "processes")
   "cr" '(C4/reload-config :wk "reload")
   "ce" '(:ignore t :wk "eval")
   "cee" '(eval-last-sexp :wk "S-exp")
   "ceb" '(eval-buffer :wk "buffer")
   "ced" '(eval-defun :wk "defun")
   "cer" '(eval-region :wk "region"))

  (defun C4/generated-conf ()
    (concat user-emacs-directory "C4.el"))

  (defun C4/esup-init ()
    "Profiles the correct init file"
    (interactive)
    (esup (C4/generated-conf)))

  (defun C4/bug-hunter-init ()
    "Debugs the correct init file"
    (interactive)
    (bug-hunter-file (C4/generated-conf)))

  (defun C4/open-config ()
    "Open files in config directory."
    (interactive)
    (find-file (concat user-emacs-directory "C4.org")))

  (defun C4/reload-config ()
    "Reloads the config in place."
    (interactive)
    (load-file (C4/generated-conf)))

#+END_SRC

**** File (=f=)

This domain wraps all commands that affect the filesystem. It includes finding and renaming files.

#+BEGIN_SRC emacs-lisp

  (C4/command-key-def
    "f" '(:ignore t :wk "file")
    "ff" '(find-file :wk "find")
    "fx" '(crux-create-scratch-buffer :wk "scratchpad")
    "fr" '(crux-rename-file-and-buffer :wk "rename"))

#+END_SRC

**** Help (=h=)

This domain wraps all commands that query Emacs for help about its functionality. It also allows me
to quickly bring up the Emacs manual for browsing.

#+BEGIN_SRC emacs-lisp

  (C4/command-key-def
   "h" '(:ignore t :wk "help")
   "ha" '(consult-apropos :wk "apropos")
   "hf" '(helpful-function :wk "function")
   "hF" '(describe-face :wk "face")
   "hc" '(helpful-command :wk "command")
   "hv" '(helpful-variable :wk "variable")
   "hk" '(helpful-key :wk "keybinding")
   "hs" '(helpful-at-point :wk "symbol at point")
   "hm" '(info-emacs-manual :wk "Emacs"))

#+END_SRC

**** Lang (=l=)

This domain wraps commands for working with programming major modes. It has some =prog-mode= globals
such as for Auto-YASnippet commands, but most of its keybindings are local to major modes for
specific languages. These are defined in their relevant sections.

#+BEGIN_SRC emacs-lisp

  (C4/command-key-def
    "l" '(:ignore t :wk "lang")
    "ll" '(:keymap lsp-command-map :package lsp-mode :wk "lsp prefix")
    "ls" '(:ignore t :wk "snippets")
    "lss" '(aya-create :wk "create a snippet")
    "lsS" '(C4/create-one-liner :wk "create a one line snippet")
    "lse" '(C4/expand-snippet :wk "expand last created snippet")
    "lsw" '(C4/save-snippet :wk "save created snippet"))

  (defun C4/create-one-liner ()
    "Create a one line snippet to expand immediately."
    (interactive)
    (modalka-mode 0)
    (aya-create-one-line))

  (defun C4/expand-snippet ()
    "Expand the last created snippet and fill it in."
    (interactive)
    (modalka-mode 0)
    (aya-expand))

  (defun C4/save-snippet ()
    "Save the created snippet to database."
    (interactive)
    (aya-persist-snippet)
    (yas/reload-all))

#+END_SRC

**** Org (=o=)

This domain wraps all commands that affect Org Mode. They allow me to view my agenda, schedule dates
and deadlines for todo items, evaluate source blocks and tangle on demand.

In addition, it binds some commands local to Org buffers like capturing and refiling.

#+BEGIN_SRC emacs-lisp

  (C4/command-key-def
    "o" '(:ignore t :wk "org")
    "oa" '(:ignore t :wk "agenda")
    "oaa" '(org-agenda-list :wk "weekly")
    "oaf" '(org-agenda :wk "full")
    "oat" '(org-set-tags-command :wk "tags")
    "ob" '(:ignore t :wk "buffer")
    "obb" '(org-insert-link :wk "link")
    "obc" '(org-capture :wk "capture")
    "obn" '(:ignore t :wk "narrow")
    "obnn" '(org-toggle-narrow-to-subtree :wk "subtree")
    "obnb" '(org-narrow-to-block :wk "block")
    "obne" '(org-narrow-to-element :wk "element")
    "obr" '(org-refile :wk "refile")
    "obs" '(C4/org-trek/body t :wk "search")
    "od" '(:ignore t :wk "date")
    "odd" '(org-deadline :wk "deadline")
    "ods" '(org-schedule :wk "schedule")
    "os" '(:ignore t :wk "special")
    "oss" '(org-edit-special :wk "edit")
    "osx" '(org-edit-src-exit :wk "exit with edits")
    "osX" '(org-edit-src-abort :wk "exit without edits")
    "ose" '(org-babel-execute-src-block :wk "execute")
    "ost" '(org-babel-tangle :wk "tangle"))

  (defhydra C4/org-trek (:timeout 10)
    "A transient mode to logically traverse an Org file."
    ("s" org-babel-next-src-block "next source block")
    ("S" org-babel-previous-src-block "previous source block")
    ("h" org-forward-heading-same-level "next heading at current level")
    ("H" org-backward-heading-same-level "previous heading at current level")
    ("v" org-next-visible-heading "next visible heading")
    ("V" org-previous-visible-heading "previous visible heading")
    ("RET" nil "exit" :exit t))

#+END_SRC

**** Project (=p=)

This domain wraps all commands that affect git project management.

I set it up to navigate projects, find files within my active ones, switch between them, and provide
a powerful git interface for managing them.

The dependencies:

+ projecile: feature rich project management for Emacs
+ magit: probably the last git workflow I'll ever need
+ forge: superior integration with Git forges (GitHub, Gitlab) to manage remote repos

#+BEGIN_SRC emacs-lisp

  (C4/command-key-def
   "p" '(:ignore t :wk "project")
   "p'" '(projectile-run-vterm :wk "open terminal")
   "pp" '(projectile-switch-project :wk "switch")
   "pf" '(projectile-find-file :wk "find file")
   "pg" '(:ignore t :wk "git")
   "pgg" '(magit-status :wk "status")
   "pgc" '(magit-commit :wk "commit")
   "pgd" '(magit-diff :wk "diff")
   "pgf" '(:ignore t :wk "forge")
   "pgff" '(forge-pull :wk "pull")
   "pgfF" '(forge-fork :wk "fork repo")
   "pgfi" '(forge-list-issues :wk "issues")
   "pgfI" '(forge-create-issue :wk "create issue")
   "pgi" '(magit-init :wk "init")
   "pgp" '(magit-push :wk "push")
   "pgP" '(magit-pull :wk "pull")
   "pgr" '(magit-remote :wk "remote")
   "pgs" '(magit-stage :wk "stage")
   "pgS" '(magit-stage-file :wk "stage file")
   "ps" '(consult-ripgrep :wk "search"))

#+END_SRC

**** Session (=q=)

This domain wraps commands that affect Emacs sessions

#+BEGIN_SRC emacs-lisp

  (C4/command-key-def
    "q" '(:ignore t :wk "session")
    "qq" '(save-buffers-kill-emacs :wk "quit")
    "qQ" '(kill-emacs :wk "really quit"))

#+END_SRC

**** Toggle (=t=)

This domain wraps commands that can be toggled. It allows me to switch variants of the main theme on
the fly and scale text. It also triggers writeroom-mode in document major modes.

#+BEGIN_SRC emacs-lisp

  (C4/command-key-def
    "t" '(:ignore t :wk "toggle")
    "tt" '(C4/theme-switcher/body :wk "theme")
    "ts" '(C4/text-scale/body :wk "scale text"))

  (defhydra C4/theme-switcher ()
    "Select a variant from main C4 themes"
    ("d" C4/light "day variant")
    ("n" C4/dark "night variant")
    ("f" C4/black "focus variant")
    ("RET" nil "exit" :exit t))

  (defun C4/light ()
    "Clap on!"
    (interactive)
    (load-theme 'minimal-light t)
    (set-face-attribute 'org-hide nil :foreground "white")
    (sml/apply-theme 'light))

  (defun C4/dark ()
    "Dimmer switch!"
    (interactive)
    (load-theme 'minimal t)
    (set-face-attribute 'org-hide nil :foreground "gray10")
    (sml/apply-theme 'dark))

  (defun C4/black ()
    "Clap off!"
    (interactive)
    (load-theme 'minimal-black t)
    (set-face-attribute 'org-hide nil :foreground "black")
    (sml/apply-theme 'dark))

  (defhydra C4/text-scale (:timeout 4)
    "Interactively scale text"
    ("+" text-scale-increase "inc")
    ("-" text-scale-decrease "dec")
    ("RET" nil "exit" :exit t))

#+END_SRC

**** Window (=w=)

This domain wraps all commands that affect windows.

Windows in Emacs can be split, moved, and closed when not needed.

This marks one of the biggest differences between Vim and Emacs: windows are /views/. Buffers in
Emacs are detached from windows and are not killed when a window closes. They persist in the
background until called into another window.

Their state is preserved.

#+BEGIN_QUOTE
C4 is built to center Emacs as the driver of my entire desktop computing experience. At this point,
Emacs largely /is/ my workstation.

So this domain includes bindings for manipulating X windows served by EXWM.

If you use this configuration and find you don't want or need Emacs to be your window manager, you
can remove the desktop bindings and the environment configuration.

Everything will still work in standalone Emacs instances. If it doesn't, please submit an issue.
#+END_QUOTE

#+BEGIN_SRC emacs-lisp

  (C4/command-key-def
   "w" '(:ignore t :wk "window")
   "ww" '(other-window :wk "cycle windows")
   "wc" '(delete-window :wk "close")
   "wC" '(delete-other-windows :wk "fill frame")
   "wd" '(:ignore t :wk "desktop")
   "wdf" '(exwm-floating-toggle-floating :wk "floating")
   "wdF" '(exwm-layout-toggle-fullscreen :wk "fullscreen")
   "wdk" '(exwm-layout-toggle-keyboard :wk "keyboard mode")
   "wdm" '(exwm-layout-toggle-mode-line :wk "mode line")
   "wdM" '(exwm-layout-toggle-minibuffer :wk "minibuffer")
   "wn" '(:ignore t :wk "navigator")
   "wnn" '(C4/window-commander/body :wk "interactive")
   "wni" '(windmove-up :wk "jump up")
   "wnI" '(windmove-swap-states-up "swap up")
   "wnk" '(windmove-down :wk "jump down")
   "wnK" '(windmove-swap-states-down :wk "swap down")
   "wnj" '(windmove-left :wk "jump left")
   "wnJ" '(windmove-swap-states-left :wk "swap left")
   "wnl" '(windmove-right :wk "jump right")
   "wnL" '(windmove-swap-states-right :wk "swap right")
   "wnw" '(windmove-display-up :wk "open next window above")
   "wnW" '(windmove-delete-up :wk "close window above")
   "wns" '(windmove-display-down :wk "open next window below")
   "wnS" '(windmove-delete-down :wk "close window below")
   "wna" '(windmove-display-left :wk "open next window left")
   "wnA" '(windmove-delete-left :wk "close window to left")
   "wnd" '(windmove-display-right :wk "open next window right")
   "wnD" '(windmove-delete-right :wk "close window to right")
   "wo" '(:ignore t :wk "open")
   "woo" '(consult-buffer-other-window :wk "buffer")
   "wof" '(find-file-other-window :wk "file")
   "wod" '(counsel-linux-app :wk "desktop app")
   "ws" '(:ignore t :wk "split")
   "wss" '(split-window-below :wk "horizontal")
   "wsS" '(split-window-right :wk "vertical"))

  (defhydra C4/window-commander (:timeout 10)
    "Interactive window navigation"
    ("SPC" other-window "cycle")
    ("c" delete-window "close")
    ("C" delete-other-windows "fill frame")
    ("i" windmove-up "jump up")
    ("I" windmove-swap-states-up "swap up")
    ("k" windmove-down "jump down")
    ("K" windmove-swap-states-down "swap down")
    ("j" windmove-left "jump left")
    ("J" windmove-swap-states-left "swap left")
    ("l" windmove-right "jump right")
    ("L" windmove-swap-states-right "swap right")
    ("w" windmove-display-up "open next above")
    ("W" windmove-delete-up "close above")
    ("s" windmove-display-down "open next below")
    ("S" windmove-delete-down "close below")
    ("a" windmove-display-left "open next to left")
    ("A" windmove-delete-left "close left")
    ("d" windmove-display-right "open next to right")
    ("D" windmove-delete-right "close right")
    ("RET" nil "exit" :exit t))

#+END_SRC
* Projects
** User Settings

Now, I need to set up Emacs for my preferred project flow. To make configuration a little easier,
I'm going to define some variables for my root project path and my GitHub username.

#+BEGIN_SRC emacs-lisp

  ;;; Set variables for my root project directory and GitHub username
  (setq C4/project-root "~/Code")
  (setq C4/gh-user "cr-jr")

#+END_SRC

** Management

Project management in my configuration is handled by projectile, the best-in-class package for efficently
working with projects under version control.

#+BEGIN_SRC emacs-lisp

  (use-package projectile
      :config
      (projectile-mode)
      :custom
      (projectile-project-search-path C4/project-root)
      (projectile-sort-order 'recently-active)
      (projectile-switch-project-action #'projectile-dired)
      :bind-keymap
      ("C-c p" . projectile-command-map))

#+END_SRC

** Version Control

My workflow is Git and GitHub driven so the packages configured here reflect that.

*** magit

Magit is probably the last Git repo manager I'll ever need. That's how good it is.

#+BEGIN_SRC emacs-lisp

  ;;; Magical Git management
  (use-package magit
    :commands (magit magit-status)
    :custom
    (magit-completing-read-function #'selectrum-completing-read)
    (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1))

#+END_SRC

*** forge

Forge is a magit extension that integrates Git forges (GitHub, Gitlab) into the magit interface and flow.

It allows complete remote repo management from right in Emacs. Including *handling issues and pull requests*.

#+BEGIN_QUOTE
Be aware that none of this configuration will work unless forge can hook into a personal access token from the
GitHub account defined by  =C4/gh-user=.
#+END_QUOTE

#+BEGIN_SRC emacs-lisp

  ;;; A Magit extension to manage Git forges (GitHub, GitLab) from Magit
  (use-package forge
      :after magit
      :custom
      (auth-sources '("~/.authinfo"))
      :config
      (ghub-request "GET" "/user" nil
        :forge 'github
        :host "api.github.com"
        :username C4/gh-user
        :auth 'forge))

#+END_SRC

*** diff-hl

The final ingredient is diff-hl: a package that shows whether a file under version control has additions,
modifications or deletions since the last commit.

#+BEGIN_SRC emacs-lisp

  ;;; Show how files have changed between commits
  (use-package diff-hl
    :after magit
    :hook
    (magit-pre-refresh . diff-hl-magit-pre-refresh)
    (magit-post-refresh . diff-hl-magit-post-refresh)
    :config
    (global-diff-hl-mode 1))

#+END_SRC

* Programming Modes

The richer programming experience offered by Emacs and the lovely ecosystem of community packages was a huge
part of why I switched over from Vim after nearly a decade of use. It requires a bit of setup, but now I have a
development workstation I can grow with and easily expand.

I looked around for packages that set a solid base for programming in general before I started looking for
language-specific support. That way each language I use gets a good starting point from which I can selectively
improve the workflow as needed.

** Parsing

Somewhat unconventional from other configurations is my inclusion of the tree-sitter package for Emacs. I
include it not just for the faster granular highlighting, but also because it allows me to /query/ syntax
definitions in supported source code.

While this would be a curiosity for most developers, it's a boon for developers thinking about creating new
programming languages or external *DSLs*. This is a space I've started to explore in my work, so in it goes.

As a bonus, some of the languages I use most come with support out of the box.

#+BEGIN_SRC emacs-lisp

  ;;; A full on parser in Emacs with highlighting definitions
  (use-package tree-sitter
    :config
    (global-tree-sitter-mode 1))

  ;; A collection of supported tree-sitter languages
  (use-package tree-sitter-langs
    :after tree-sitter)

#+END_SRC

** Syntax Highlighting

This section contains packages with the aim of providing a little more contextual highlighting to programming
modes. Since I use a default theme that doesn't make a lot of assumptions about how I want my code
highlighted, it means I can judiciously add syntax information that actually helps rather than creates noise.

*** Faces

I'm going to adjust some of the faces provided by tree-sitter now.

#+BEGIN_SRC emacs-lisp

  ;;; Set syntax highlighting faces

  ;; set comment face
  (set-face-attribute 'font-lock-comment-face nil :weight 'bold :inherit 'italic)

  ;; set keyword face
  (set-face-attribute 'font-lock-keyword-face nil :inherit 'bold)

  ;; set constants face
  (set-face-attribute 'font-lock-constant-face nil :font C4/font :weight 'black)

  ;; set built-in face
  (set-face-attribute 'font-lock-builtin-face nil :inherit 'bold)

  ;; set function name face
  (set-face-attribute 'font-lock-function-name-face nil :font C4/font :weight 'black)

  ;; set string face
  (set-face-attribute 'font-lock-string-face nil :weight 'normal :slant 'normal :inherit 'italic)

#+END_SRC

*** rainbow-delimiters

This package is incredibly helpful in keeping track of how many levels deep I am in a complex LISP s-exp and it
helps a little in other ways, too.

#+BEGIN_SRC emacs-lisp

  ;;; When I'm knee deep in parens
  (use-package rainbow-delimiters
    :hook
    (prog-mode . rainbow-delimiters-mode)
    (prog-mode . prettify-symbols-mode))

#+END_SRC

** Linting

C4 uses flycheck for code linting.

#+BEGIN_SRC emacs-lisp

  ;;; Code linting package that flies
  (use-package flycheck
      :hook (prog-mode . flycheck-mode))

#+END_SRC

** Formatting
*** apheleia

C4 uses Apheleia for code formating. It's a language-agnostic formatting package that allows the support of
new formatters as well.

#+BEGIN_SRC emacs-lisp

    ;;; Universal code formatting package
    (use-package apheleia
      :straight
      '(apheleia
        :host github
        :repo "raxod502/apheleia")
      :hook (prog-mode . apheleia-mode))

#+END_SRC

*** smartparens

This package autopairs delimiters for a variety of programming modes.

#+BEGIN_SRC emacs-lisp

  ;;; Autopair delimiters
  (use-package smartparens
    :hook
    (prog-mode . smartparens-mode)
    :config
    (require 'smartparens-config))

#+END_SRC

*** aggressive-indent-mode

Automatic indentation is another sanity check for overally programming.

#+BEGIN_SRC emacs-lisp

  ;;; Automatic indentation for my sanity
  (use-package aggressive-indent
    :hook
    (prog-mode . aggressive-indent-mode))

#+END_SRC

** Autocompletion

Autocompletion is included with Company with an interface provided by company-box.

#+BEGIN_SRC emacs-lisp

  ;;; Code autocomplete with Company
  (use-package company
    :hook (prog-mode . company-mode))

  ;;; A nice Company interface
  (use-package company-box
    :hook (company-mode . company-box-mode))

#+END_SRC

** Language Server Protocol

Language Server Protocol is /the/ killer feature of modern IDEs. The most significant contribution of VSCode
can be used in Emacs without much issue.

First, I'm setting it up for general use. Later, in the appropriate language's section, I add the enhancements.

#+BEGIN_SRC emacs-lisp

  ;;; Language Server Protocol package for rich IDE features
  (use-package lsp-mode
    :init
    (setq lsp-keymap-prefix "")
    :hook
    (prog-mode . lsp-deferred)
    (lsp-mode . lsp-enable-which-key-integration)
    :commands (lsp lsp-deferred))

  ;; UI enhancements for lsp-mode
  (use-package lsp-ui
    :after lsp-mode
    :commands lsp-ui-mode)
#+END_SRC

** Debugging

This configuration uses the Debug Adapter Protocol for supported languages while falling back to more
specialized debgugging packages for unsupported languages in their relevant sections.

#+BEGIN_SRC emacs-lisp

  ;;; The debugging complement to LSP
  (use-package dap-mode
    :hook
    (prog-mode . dap-mode)
    (dap-stopped . (lambda (arg) (call-interactively #'dap-hydra))))

#+END_SRC

** Snippets

Snippets are valuable for my workflow. And YASnippet is the Emacs standard for using them. I also
included a community-supported snippet package auto-yasnippet to create custom snippets as needed.

#+BEGIN_SRC emacs-lisp

  ;;; Snippet support

  ;; Setup YASnippet
  (use-package yasnippet
    :config
    (yas-global-mode 1))

  ;; Setup snippet collection
  (use-package yasnippet-snippets)

  ;; Setup Auto-YASnippet
  (use-package auto-yasnippet)

#+END_SRC

** Language Support

The groundwork is in place, so now I'm going to selectively enhance some programming modes. The
language support of my configuration includes both languages I work with and those I'm interested in
studying.

If you don't need support for a language below, adding a =PROPERTIES= block under the heading for
that language with =:header-args:emacs-lisp: :tangle no= will disable generation.

*** TODO Lisp Family
**** Common Lisp

The premier package for editing Common Lisp is SLIME, and I'm using a newer, actively maintained
fork called SLY in my configuration.

#+BEGIN_SRC emacs-lisp

  ;;; Lang: Common Lisp

  ;; Setup SLY
  (use-package sly
    :general

    ;; Connections
    (C4/command-key-def
      :keymaps 'sly-mode-map
      "lC" '(:ignore t :wk "SLY: connections")
      "lCc" '(sly :wk "invoke")
      "lCl" '(sly-list-connections :wk "list active")
      "lC>" '(sly-next-connection :wk "next")
      "lC<" '(sly-prev-connection :wk "previous")
      )

    ;; Annotations
    (C4/command-key-def
      :keymaps 'sly-mode-map
      "la" '(:ignore t :wk "SLY: annotations")
      "lan" '(sly-next-note :wk "next note")
      "laN" '(sly-previous-note :wk "prev note")
      "laR" '(sly-remove-notes :wk "remove all"))

    ;; Docs
   (C4/command-key-def
      :keymaps 'sly-mode-map
      "ld" '(:ignore t :wk "SLY: doc")
      "ldd" '(sly-autodoc-mode :wk "autodoc toggle")
      "ldm" '(sly-autodoc-manually :wk "autodoc manually")
      "lda" '(sly-arglist :wk "defun arglist")
      "lds" '(sly-info :wk "SLY manual"))

    ;; Compiling
    (C4/command-key-def
      :keymaps 'sly-mode-map
      "lc" '(:ignore t :wk "SLY: compile")
      "lcc" '(sly-compile-defun :wk "defun")
      "lE" '(next-error :wk "show errors")
      "lcr" '(sly-compile-region :wk "region")
      "lcf" '(sly-compile-file :wk "file")
      "lcF" '(sly-compile-and-load-file :wk "and load"))

    ;; Evaluation
    (C4/command-key-def
      :keymaps 'sly-mode-map
      "le" '(:ignore t :wk "SLY: eval")
      "lee" '(sly-eval-last-expression :wk "expression")
      "leE" '(sly-pprint-eval-last-expression :wk "expression to buffer")
      "lei" '(sly-interactive-eval :wk "interactive")
      "led" '(sly-eval-defun :wk "defun")
      "ler" '(sly-eval-region :wk "region")
      "leR" '(sly-pprint-eval-region :wk "region to buffer")
      "leb" '(sly-eval-buffer :wk "buffer"))

    ;; Files
    (C4/command-key-def
      :keymaps 'sly-mode-map
      "lf" '(sly-load-file :wk "load file"))

    ;; Macros
    (C4/command-key-def
      :keymaps 'sly-mode-map
      "lm" '(:ignore t :wk "macro")
      "lmm" '(sly-expand-1 :wk "expand")
      "lmM" '(sly-macroexpand-all :wk "expand all")
      "lmc" '(sly-compiler-macroexpand-1 :wk "compiler expand")
      "lmC" '(sly-compiler-macroexpand :wk "compiler expand repeatedly")
      "lmf" '(sly-format-string-expand :wk "format string")
      "lmr" '(sly-macroexpand-1-inplace :wk "expand repeatedly")
      "lmR" '(sly-macroexpand-again :wk "repeat last expansion")
      "lmu" '(sly-macroexpand-undo :wk "undo last expansion"))

    ;; Source
    (C4/command-key-def
      :keymaps 'sly-mode-map
      "lS" '(:ignore t :wk "SLY: source code")
      "lSs" '(:ignore t :wk "SLY: definitions")
      "lSss" '(sly-edit-definition :wk "edit")
      "lSsS" '(sly-edit-definition-other-window :wk "edit (other window)")
      "lSsp" '(sly-pop-find-definition-stack :wk "go back to invocation")
      "lSd" '(:ignore t :wk "SLY: describe")
      "lSdd" '(sly-describe-symbol :wk "symbol")
      "lSdf" '(sly-describe-function :wk "function")
      "lSda" '(sly-apropos :wk "apropos")
      "lSdA" '(sly-apropos-all :wk "apropos all")
      "lSd C-a" '(sly-apropos-package :wk "apropos package")
      "lSdh" '(sly-hyperspec-lookup :wk "hyperspec lookup")
      "lSdH" '(sly-hyperspec-lookup-format :wk "hyperspec lookup [format]")
      "lSd C-h" '(sly-hyperspec-lookup-reader-macro :wk "hyperspec lookup [reader macro]")
      "lSx" '(:ignore t :wk "SLY: cross-reference")
      "lSxr" '(sly-edit-uses :wk "find symbol")
      "lSxc" '(sly-who-calls :wk "find callers")
      "lSxC" '(sly-calls-who :wk "find callees")
      "lSxg" '(sly-who-references :wk "find global")
      "lSxG" '(sly-who-binds :wk "find global bindings")
      "lSx C-g" '(sly-who-sets :wk "find global assignments")
      "lSxm" '(sly-who-macroexpands :wk "show macroexpansions")
      "lSxM" '(sly-who-specializes :wk "show methods")
      "lSe" '(sly-edit-value "edit value")
      "lSu" '(sly-undefine-function "undefine function"))
    :hook
    (common-lisp-mode . sly-mode))

#+END_SRC

I set keybindings for common SLY operations under the =lang= mnemonic. So when =common-lisp= is the
major mode of a buffer, these keybindings activate.

*** TODO C
*** TODO Elixir
*** TODO Elm
*** TODO Factor
*** TODO Go
*** TODO Haskell
*** TODO JavaScript/TypeScript
*** TODO Julia
*** TODO Nim
*** TODO Prolog
*** TODO R
*** TODO Rust
*** TODO Web Dev
* Document Modes
** Spelling
** Grammar
** Dictionary & Thesaurus
** Format Support
*** Org

My main document mode is Org Mode. I use it for nearly everything, so it's extensively configured and includes
quite a few addons.

**** User Settings

First, I define some variables to make adjustments easier.

#+BEGIN_SRC emacs-lisp

  ;;; Variables for Org Mode configuration
  (setq C4/org-root-path "~/Documents/Org")
  (setq C4/org-agenda-files '("Tasks.org" "Projects.org"))

#+END_SRC

**** Configuration

To keep things clean in this section, I use the =noweb= property of Org-babel so I can define more complex
settings in their own section.

A lot of this setup was lifted directly from Emacs from Scratch and I'll customize it over time as my Org Mode
flow becomes more personal.

#+BEGIN_SRC emacs-lisp :noweb yes

  ;;; Org setup
  (use-package org
    :hook
    (org-mode . variable-pitch-mode)
    (org-mode . visual-line-mode)
    (org-mode . org-indent-mode)
    (org-mode . auto-fill-mode)
    :config
    (setq org-ellipsis " ↴")
    (setq org-directory C4/org-root-path)
    <<org-agenda>>
    <<org-templates>>
    <<org-literate>>
    (advice-add 'org-refile :after 'org-save-all-org-buffers)
    (add-to-list 'org-refile-targets '("C4.org" :maxlevel . 3)))

#+END_SRC

***** Agenda

Now, I set up Org for task management.

#+NAME: org-agenda
#+BEGIN_SRC emacs-lisp :tangle no

  ;;; Org agenda flow
  (setq org-agenda-start-with-log-mode t)
  (setq org-log-done 'time)
  (setq org-log-into-drawer t)

  (setq org-agenda-files C4/org-agenda-files)

  (setq org-todo-keywords
        '((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d!)")
          (sequence
           "BACKLOG(b)" "PLAN(p)" "READY(r)" "ACTIVE(a)" "REVIEW(v)"
           "WAIT(w@/!)" "HOLD(h)" "|" "COMPLETED(c)" "CANC(k@)")))

  (setq org-refile-targets
        '(("Archive.org" :maxlevel . 1)
          ("Tasks.org" :maxlevel . 1)))

  (setq org-tag-alist
        '((:startgroup)
          ("@product" . ?P)
          ("@experiment" . ?E)
          ("@resource" . ?R)
          ("@learning" . ?L)
          ("@teaching" . ?T)
          (:endgroup)
          ("prototyping" . ?p)
          ("developing" . ?d)
          ("documenting" . ?D)
          ("testing" . ?t)
          ("refactoring" . ?r)))

  (setq org-agenda-custom-commands
        '(("d" "Dashboard"
       ((agenda "" ((org-deadline-warning-days 7)))
         (todo "NEXT"
                ((org-agenda-overriding-header "Next Tasks")))))

      ("P" "Products" tags-todo "@product")
        ("E" "Experiments" tags-todo "@experiment")
        ("R" "Resources" tags-todo "@resource")
        ("L" "Learning" tags-todo "@learning")
        ("T" "Teaching" tags-todo "@teaching")

        ("s" "Workflow Status"
         ((todo "WAIT"
                 ((org-agenda-overriding-header "Waiting on External")
             (org-agenda-files org-agenda-files)))
           (todo "REVIEW"
                ((org-agenda-overriding-header "Under Review")
             (org-agenda-files org-agenda-files)))
          (todo "PLAN"
                ((org-agenda-overriding-header "Planning")
             (org-agenda-files org-agenda-files)))
          (todo "BACKLOG"
                ((org-agenda-overriding-header "Project Backlog")
             (org-agenda-files org-agenda-files)))
          (todo "READY"
                ((org-agenda-overriding-header "Ready for Work")
             (org-agenda-files org-agenda-files)))
          (todo "ACTIVE"
                ((org-agenda-overriding-header "Active Projects")
             (org-agenda-files org-agenda-files)))
          (todo "COMPLETED"
                ((org-agenda-overriding-header "Completed Projects")
             (org-agenda-files org-agenda-files)))
          (todo "CANC"
                ((org-agenda-overriding-header "Cancelled Projects")
             (org-agenda-files org-agenda-files)))))))

#+END_SRC

***** Capture Templates

In this section, I'm defining my Org-capture templates. It's just the one right now, but more will be added as
I need them.

#+NAME: org-templates
#+BEGIN_SRC emacs-lisp :tangle no

  ;;; Org template definitions
  (setq org-capture-templates
      `(("t" "Tasks / Projects")
          ("tt" "Task" entry (file+olp "Tasks.org" "Inbox")
            "* TODO %?\n %U\n %a\n %i" :empty-lines 1)))

#+END_SRC

***** Literate Programming

Finally, I set my configuration up for Org-babel so I can do literate programming in any language I want.

#+NAME: org-literate
#+BEGIN_SRC emacs-lisp :tangle no

  ;;; Org-babel setup
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (js . t)))

  (setq org-src-fontify-natively t)
  (setq org-confirm-babel-evaluate nil)

#+END_SRC

**** Addons
***** org-superstar

Org Superstar is a package that makes Org Mode bullets (even lists) much prettier.

#+BEGIN_SRC emacs-lisp

  ;;; Org Superstar makes your bullets bang louder
  (use-package org-superstar
    :after org
    :hook
    (org-mode . org-superstar-mode)
    :custom-face
    (org-superstar-leading ((t (:inherit 'org-hide))))
    :init
    (setq org-superstar-headline-bullets-list
          '("⚀" "⚁" "⚂" "⚃" "⚄" "⚅")))

#+END_SRC

***** visual-fill-column

This package provides a more pleasant writing experience with Org Mode. I used darkroom for a while,
but it does a little too much and doesn't seem to play nice with org-indent-mode.

#+BEGIN_SRC emacs-lisp

  ;;; visual-fill-column does just enough UI adjustment
  ;;; for Org Mode
  (use-package visual-fill-column
    :custom
    (visual-fill-column-width 120)
    (visual-fill-column-center-text t)
    :hook
    (visual-line-mode . visual-fill-column-mode)
    :config
    (advice-add 'text-scale-adjust :after #'visual-fill-column-adjust))

#+END_SRC

*** Markdown
*** LaTeX
* Desktop Environment

Yes, Emacs is my window manager. And so far, I'm loving EXWM. If you don't love it, add a properties drawer to
this heading similar to the one at the very top of this file. Then change =:tangle= to =no=. The configuration
won't build anything in this section after that.

** Setup

For my machine, I need to do a few things before I can even use EXWM.

*** .xinitrc

To actually use Emacs as my desktop environment, I need to create a =.xinitrc=.

#+BEGIN_SRC sh :tangle "~/.xinitrc"
# Caps to CTRL
setxkbmap -option ctrl:nocaps

# Disable touchpad
xinput set-prop 12 "Device Enabled" 0

# Default cursor
xsetroot -cursor_name left_ptr

# Xresources
xrdb ~/.Xresources

# Settings
gnome-settings-daemon &

# Autostart programs
dex -a

# Removable media
udiskie &

# Notifications
dunst &

# Start EXWM
exec dbus-launch --exit-with-session emacs -mm --debug-init -f exwm-enable
#+END_SRC

*** multi-monitor

I also use software (ARandR) to configure my multi-monitor setup.

#+BEGIN_SRC sh :tangle "./desktop/multihead.sh" :tangle-mode (identity #o755)
#!/bin/sh
xrandr --output LVDS --primary --mode 1366x768 --pos 241x1080 --rotate normal --output VGA-0 --off --output HDMI-0 --mode 1920x1080 --pos 0x0 --rotate normal
#+END_SRC

Finally, I need to load in the main desktop package.

** Configuration

Now, I'll actually configure EXWM.

Like the Org section, I'm breaking up this monolithic block of code into smaller bits.

#+BEGIN_SRC emacs-lisp :noweb yes

  ;;; Initialize EXWM if GUI Emacs
  (use-package exwm
    :if window-system
    :config
    <<exwm-startup>>

    (display-time-mode t)

    (setq exwm-workspace-number 4)
    (setq display-time-default-load-average nil)
    (setq exwm-workspace-warp-cursor t)
    (setq focus-follows-mouse t)

    <<exwm-keybindings>>

    ;; Update window class with the buffer name
    (add-hook 'exwm-update-class-hook #'C4/exwm-update-class)

    <<exwm-randr>>
    <<exwm-systemtray>>)

  (defun C4/exwm-update-class ()
    (exwm-workspace-rename-buffer (concat "X: " exwm-class-name)))

#+END_SRC

*** startup

#+NAME: exwm-startup
#+BEGIN_SRC emacs-lisp :tangle no

  ;; Wallpaper setup
  (start-process-shell-command
   "nitrogen" nil "nitrogen --restore")

#+END_SRC

*** keybindings

#+NAME: exwm-keybindings
#+BEGIN_SRC emacs-lisp :tangle no

  ;;; Ensure these keys work everywhere
  (setq exwm-input-prefix-keys
        '(?\C-x
          ?\C-u
          ?\C-h
          ?\C-\
          ?\M-x
          ?\M-`
          ?\M-&
          ?\M-:
          ?\s-\ ))

  ;;; Global keys for getting around in EXWM
  (setq exwm-input-global-keys
        `(([?\s-I] . windmove-swap-states-up)
          ([?\s-i] . windmove-up)
          ([?\s-L] . windmove-swap-states-right)
          ([?\s-l] . windmove-right)
          ([?\s-K] . windmove-swap-states-down)
          ([?\s-k] . windmove-down)
          ([?\s-J] . windmove-swap-states-left)
          ([?\s-j] . windmove-left)
          ([?\s-r] . exwm-reset)
          ([?\s-Q] . kill-emacs)
          ([?\s-q] . exwm-restart)
          ([?\s-W] . exwm-workspace-swap)
          ([?\s-w] . exwm-workspace-switch)
          ([?\s-D] . app-launcher-run-app)
          ([?\s-d] . (lambda (cmd)
                       (interactive (list (read-shell-command "$ ")))
                       (start-process-shell-command cmd nil cmd)))
          ,@(mapcar (lambda (i)
                      `(,(kbd (format "s-%d" i)) .
                        (lambda ()
                          (interactive)
                          (exwm-workspace-switch-create ,i))))
                    (number-sequence 0 9))))

  (define-key exwm-mode-map [?\C-q] 'exwm-input-send-next-key)

#+END_SRC

*** randr

#+NAME: exwm-randr
#+BEGIN_SRC emacs-lisp :tangle no

   ;;; Multi monitor workspaces
  (require 'exwm-randr)
  (setq exwm-randr-workspace-monitor-plist
        '(0 "LVDS" 1 "LVDS" 2 "HDMI-0" 3 "HDMI-0"))
  (start-process-shell-command "xrandr" nil
                               (concat user-emacs-directory "desktop/multihead.sh"))
  (exwm-randr-enable)

#+END_SRC

*** systemtray

#+NAME: exwm-systemtray
#+BEGIN_SRC emacs-lisp :tangle no

  ;;; Enable a system tray in EXWM
  (require 'exwm-systemtray)
  (setq exwm-systemtray-height 16)
  (exwm-systemtray-enable)

#+END_SRC

** Addons

*** application-launcher

#+BEGIN_SRC emacs-lisp

  ;; Application launcher
  (use-package app-launcher
    :straight '(app-launcher :host github :repo "SebastienWae/app-launcher"))

#+END_SRC

*** desktop-environment

#+BEGIN_SRC emacs-lisp

  ;; EXWM: Desktop Environment
  (use-package desktop-environment
    :after exwm
    :diminish
    :bind
    ("s-l" . windmove-right)
    :config
    (desktop-environment-mode))

#+END_SRC
