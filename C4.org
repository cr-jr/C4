#+TITLE: C4 Configuration
#+DATE: 2021-01-23
#+AUTHOR: Chatman R. Jr
:PROPERTIES:
:header-args: :mkdirp yes
:header-args:emacs-lisp: :tangle "./C4.el" :session "C4"
:END:

* Summary

This configuration is my personal configuration/sandbox that grows as I use my favorite productivity
environment and learn how to do more with it.

C4 prioritizes ease, convenience and performance. The aesthethic and workflow are rather spartan,
building from a base of Emacs itself instead of forcing it to be something else.

This is an Org-driven configuration consisting of this file (=C4.org=), the generated =C4.el= and
the =init.el= that loads it on startup.

If something doesn't add value to my workflow, it simply isn't here.

Custom variables and procedures in this config are always prefixed with =C4=.

* Initialization
** Package Management

C4 requires [[https://github.com/raxod502/straight.el][straight.el]] and [[https://github.com/jwiegley/use-package][use-package]], so that gets loaded in first.

#+BEGIN_SRC emacs-lisp
  ;;; Setup straight.el with use-package
  (setq straight-repository-branch "develop")
  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))

  ;; use-package integration
  (straight-use-package 'use-package)
  (setq straight-use-package-by-default t)

#+END_SRC

** Building the Configuration

After package setup, we need to load in [[https://orgmode.org][Org Mode]] to build the configuration as well as attach a hook
to rebuild it on save.

#+BEGIN_SRC emacs-lisp

  ;;; Need Org Mode to be first package installed because it builds the config.
  (use-package org
    :straight org-plus-contrib)

  ;; Generate C4.el from the source blocks in C4.org
  (defun C4/init ()
    (org-babel-tangle-file
     (concat user-emacs-directory "C4.org")
     (concat user-emacs-directory "C4.el")))

  ;; Always generate on load
  (C4/init)

  ;; Setup a hook to re-tangle the config on modification.
  (add-hook 'org-mode-hook
            (lambda () (add-hook 'after-save-hook #'C4/init)))

#+END_SRC

C4 is a module-based configuration, so now we load those.

#+BEGIN_SRC emacs-lisp

  (require 'cl-lib)

  (require 'base
           (concat user-emacs-directory "modules/base.el"))
  (require 'projects
           (concat user-emacs-directory "modules/projects.el"))
  (require 'code
           (concat user-emacs-directory "modules/code.el"))
  (require 'documents
           (concat user-emacs-directory "modules/documents.el"))
  (require 'desktop
           (concat user-emacs-directory "modules/desktop.el"))

#+END_SRC

** Startup Performance
*** Garbage collection

The first optimization involves increasing the Emacs garbage collection threshold to =100MB= on
startup. This gives a slight boost in initialization. After Emacs starts up, we use a hook to reduce
the threshold back to its approximate initial state.

#+BEGIN_SRC emacs-lisp

  ;; Raise the garbage collection threshold high as emacs starts
  (setq gc-cons-threshold 100000000)
  (setq read-process-output-max (* 1024 1024))

  ;; Drop it down once loaded
  (add-hook 'after-init-hook #'(lambda () (setq gc-cons-threshold 1000000)))

#+END_SRC

** Housekeeping

Now I want to do some decluttering. Emacs has a way of operating with files that can leave a lot of
crap behind in my filesystem, so I needed to do a little cleanup and ordering of where and if it
generates temporary files and directories.

*** Inhibit lockfiles and custom files

My experience with lockfiles is that they add a lot of noise to my directories and projects, so I'm
just going to disable them entirely. The same goes for custom files, because I prefer to do all of
my customizations with Emacs Lisp.

#+BEGIN_SRC emacs-lisp

  ;; Lockfiles do more harm than good
  (setq create-lockfiles nil)

  ;; Custom files just add clutter
  (setq custom-file null-device)

#+END_SRC

*** no-littering

no-littering is a great package that ensures files and directories generated by Emacs or its
packages are allocated to their proper places. The killer feature is how it allows you to set a
central directory for all autosaved files.

#+BEGIN_SRC emacs-lisp

  ;; Put temporary and data files in proper locations
  (use-package no-littering
    :custom
    (auto-save-file-name-transforms
     `((".*" ,(no-littering-expand-var-file-name "auto-save/") t))))

#+END_SRC

*** Create parent directories automatically

One great thing about Emacs is that I can manage my ideas and work as they come. I streamline this
by telling Emacs to automatically create directories that don't exist for new files. This allows me
to build the file structure for my projects on the fly.

#+BEGIN_SRC emacs-lisp

  ;; Create parent dirs when opening new files
  (add-to-list 'find-file-not-found-functions #'C4/create-parent)

  (defun C4/create-parent ()
    "Ensures that the parent dirs are created for a nonexistent file."
    (let ((parent-directory (file-name-directory buffer-file-name)))
      (when (and (not (file-exists-p parent-directory))
                 (y-or-n-p (format
                            "Directory `%s' does not exist! Create it?"
                            parent-directory)))
        (make-directory parent-directory t))))

#+END_SRC

*** whitespace-cleanup-mode

whitespace-cleanup-mode is a package that intelligently checks files for errant whitespace and
cleans it up before saving. By default, C4 enables this behavior globally.

Some modes can be set to disable this behavior as exceptions.

#+BEGIN_SRC emacs-lisp

  ;;; Clean up whitespace in all major modes on save
  (use-package whitespace-cleanup-mode
    :config
    (global-whitespace-cleanup-mode t))

#+END_SRC

** Debugging the Configuration

When things break, I need ways of figuring out the problem. And without measurements, I can't make improvements.

*** esup

ESUP (Emacs Start Up Profiler) is an invaluable package for benchmarking how quickly Emacs loads. My
aim: make C4 feature complete for my needs while also loading fast enough for my slightly older laptop.

#+BEGIN_SRC emacs-lisp

  ;;; Benchmark Emacs startup to debug performance
  (use-package esup)

#+END_SRC

*** elisp-bug-hunter

elisp-bug-hunter is a package that allows me to track down and eliminate bugs in C4 that might be
hiding in the tall grass.

#+BEGIN_SRC emacs-lisp

  ;;; Debug init file errors
  (use-package bug-hunter)

#+END_SRC

*** explain-pause-mode

explain-pause-mode is like =top= (more accurately =htop=) for Emacs. It allows you see all recently
run operations and discover which ones are making Emacs lag. This ensures tight performance carries
over for more than just startup times.

#+BEGIN_SRC emacs-lisp

  ;;; Check running processes in Emacs for slowdowns
  (use-package explain-pause-mode
    :config
    (explain-pause-mode))

#+END_SRC

* Utilities

This configuration includes the crux package. It's way too useful not to use. Especially since I
opted out of Vim emulation.

#+BEGIN_SRC emacs-lisp

  (use-package crux
    :hook
    (find-file . crux-reopen-as-root-mode))

#+END_SRC

* Keybindings

This configuration sets up keybindings immediately after initialization, because it uses a non-evil
modal setup that responds to modes in context.

It does this by using:

+ modalka to enable a global command mode
+ hydra for definining transient mode states for complex operations
+ general.el unites the keybindings interface under global and mnemonic bindings
+ which-key allows keybinding discoverability

** Rationale

Emacs is slowly pushing me to think less like a Vimmer, and because of this, evil-mode feels limiting.

I'm beginning to understand that major and minor modes *are already contextual* and it makes the
most sense to define keybindings in Emacs according to which modes are /active/ in a buffer rather
than by toggling arbitrary states.

** Making bindings discoverable

#+BEGIN_SRC emacs-lisp

  ;;; Setup which-key for keybinding discoverability
  (use-package which-key
    :custom
    (which-key-idle-delay 0.96)
    :config
    (which-key-mode))

#+END_SRC

** Command Mode

Command Mode is a global modal state for quickly issuing commands to Emacs via a set of mnemonic conventions.

#+BEGIN_QUOTE
If you're not using EXWM, make sure you remove that last hook.
#+END_QUOTE

*** Initialization

#+BEGIN_SRC emacs-lisp

  ;;; Command mode initialization
  (use-package modalka
    :commands modalka-mode
    :hook
    (text-mode . modalka-mode)
    (prog-mode . modalka-mode)
    (exwm-mode . modalka-mode))

#+END_SRC

*** Setup

#+BEGIN_SRC emacs-lisp

  ;;; Command mode setup
  (use-package general
    :config
    ;; Unbind C-SPC and rebind it to toggle Command Mode
    (global-unset-key (kbd "C-SPC"))
    (general-def "C-SPC" 'modalka-mode)

    ;; Create a global definitiion key for non-prefixed Command Mode actions
    (general-create-definer C4/global-key-def
      :keymaps 'modalka-mode-map)

    ;; Create a mnemonic leader key under Command Mode
    (general-create-definer C4/leader-key-def
      :keymaps 'modalka-mode-map
      :prefix "SPC"
      :global-prefix [\s-SPC])

    ;; Command mode universals
    (C4/global-key-def
      "." '(repeat :wk "repeat last command")
      ">" '(consult-complex-command :wk "repeat command history")
      "RET" '(modalka-mode :wk "insert text"))

    ;; Command mode navigation
    (C4/global-key-def
      "w" '(scroll-down-command :wk "scroll up the buffer")
      "W" '(beginning-of-buffer :wk "jump point to beginning of buffer")
      "s" '(scroll-up-command :wk "scroll down the buffer")
      "S" '(end-of-buffer :wk "jump point to end of buffer")
      "a" '(beginning-of-line-text :wk "jump point to beginning of line")
      "A" '(beginning-of-line :wk "jump point to beginning of line [absolute]")
      "d" '(end-of-line :wk "jump point to end of line")
      "i" '(previous-logical-line :wk "previous line")
      "k" '(next-logical-line :wk "next line")
      "j" '(backward-char :wk "previous char")
      "l" '(forward-char :wk "next char")
      "h" '(backward-word :wk "jump point to previous word")
      ";" '(forward-word :wk "jump point to next word")))

  ;;; Setup transient mode-ish states
  (use-package hydra)

#+END_SRC

*** Mnemonics

The C4 mnemonic keybindings all share =SPC= as a prefix and =s-SPC= to issue these keybindings
globally (as in X applications when using EXWM).

I create a few global commands under Command Mode, and then the rest are encapsulated in domains of
influence. The mnemonic keybinding style is heavily inspired by Doom Emacs and represent those
commands I use all the time.

Some of the commands will trigger a transient state with its own local keybindings.

Now, the global commands:

#+BEGIN_SRC emacs-lisp

  (C4/leader-key-def
    "'" '(vterm :wk "open terminal from current dir")
    "SPC" '(universal-argument :wk "command modifier"))

#+END_SRC

Now we can open a terminal from anywhere, prefix our mnemonic commands to modify them, and
immediately quit an errant keystroke.

**** Buffer (=b=)

This domain wraps all commands that affect buffers Lowercase bindings affect only the current
buffer, uppercase bindings affect /all/ active buffers or modify a buffer-local command.

#+BEGIN_SRC emacs-lisp

  (C4/leader-key-def
    "b" '(:ignore t :wk "buffer")
    "bb" '(consult-buffer :wk "switch")
    "bB" '(consult-buffer-other-window :wk "switch other window")
    "bd" '(kill-current-buffer :wk "kill")
    "bD" '(kill-some-buffers :wk "kill multiple")
    "bn" '(:ignore t :wk "narrow")
    "bnn" '(widen :wk "reset")
    "bnd" '(narrow-to-defun :wk "to defun")
    "bnp" '(narrow-to-page :wk "to page")
    "bnr" '(narrow-to-region :wk "to region")
    "bk" '(kill-current-buffer :wk "kill")
    "bK" '(kill-some-buffers :wk "kill multiple")
    "bs" '(:ignore t :wk "search")
    "bss" '(ctrlf-forward-literal :wk "forward literal")
    "bsS" '(ctrlf-backward-literal :wk "backward literal")
    "bsf" '(ctrlf-forward-fuzzy :wk "forward fuzzy")
    "bsF" '(ctrlf-backward-fuzzy :wk "backward fuzzy")
    "bsr" '(ctrlf-forward-regexp :wk "forward regexp")
    "bsR" '(ctrlf-backward-regexp :wk "backward regexp")
    "bw" '(save-buffer :wk "write")
    "bW" '(save-some-buffers :wk "write modified"))

#+END_SRC

**** Config (=c=)

This domain wraps all commands that make it easier to work with my configuration itself. This
includes quickly opening my config, debugging, and reloading my config.

In addition, I define bindings that make it easier to evaluate expressions, defuns and regions in
place as I try out new settings.

#+BEGIN_SRC emacs-lisp

  (C4/leader-key-def
   "c" '(:ignore t :wk "C4 config")
   "cc" '(C4/open-config :wk "open")
   "cd" '(:ignore t :wk "debug")
   "cdd" '(C4/esup-init :wk "startup")
   "cde" '(C4/bug-hunter-init :wk "errors")
   "cdp" '(explain-pause-top :wk "processes")
   "cr" '(C4/reload-config :wk "reload")
   "ce" '(:ignore t :wk "eval")
   "cee" '(eval-last-sexp :wk "S-exp")
   "ceb" '(eval-buffer :wk "buffer")
   "ced" '(eval-defun :wk "defun")
   "cer" '(eval-region :wk "region"))

  (defun C4/generated-conf ()
    (concat user-emacs-directory "C4.el"))

  (defun C4/esup-init ()
    "Profiles the correct init file"
    (interactive)
    (esup (C4/generated-conf)))

  (defun C4/bug-hunter-init ()
    "Debugs the correct init file"
    (interactive)
    (bug-hunter-file (C4/generated-conf)))

  (defun C4/open-config ()
    "Open files in config directory."
    (interactive)
    (find-file (concat user-emacs-directory "C4.org")))

  (defun C4/reload-config ()
    "Reloads the config in place."
    (interactive)
    (load-file (C4/generated-conf)))

#+END_SRC

**** File (=f=)

This domain wraps all commands that affect the filesystem. It includes finding and renaming files.

#+BEGIN_SRC emacs-lisp

  (C4/leader-key-def
    "f" '(:ignore t :wk "file")
    "ff" '(find-file :wk "find")
    "fr" '(crux-rename-file-and-buffer :wk "rename"))

#+END_SRC

**** Help (=h=)

This domain wraps all commands that query Emacs for help about its functionality. It also allows me
to quickly bring up the Emacs manual for browsing.

#+BEGIN_SRC emacs-lisp

  (C4/leader-key-def
   "h" '(:ignore t :wk "help")
   "ha" '(consult-apropos :wk "apropos")
   "hf" '(describe-function :wk "function")
   "hF" '(describe-face :wk "face")
   "hc" '(helpful-command :wk "command")
   "hv" '(describe-variable :wk "variable")
   "hk" '(helpful-key :wk "keybinding")
   "hs" '(helpful-at-point :wk "symbol at point")
   "hm" '(info-emacs-manual :wk "Emacs"))

#+END_SRC

**** Org (=o=)

This domain wraps all commands that affect Org Mode. They allow me to view my agenda, schedule dates
and deadlines for todo items, evaluate source blocks and tangle on demand.

In addition, it binds some commands local to Org buffers like capturing and refiling.

#+BEGIN_SRC emacs-lisp

  (C4/leader-key-def
    "o" '(:ignore t :wk "org")
    "oa" '(:ignore t :wk "agenda")
    "oaa" '(org-agenda-list :wk "weekly")
    "oaf" '(org-agenda :wk "full")
    "oat" '(org-set-tags-command :wk "tags")
    "ob" '(:ignore t :wk "buffer")
    "obb" '(org-insert-link :wk "link")
    "obc" '(org-capture :wk "capture")
    "obn" '(:ignore t :wk "narrow")
    "obnn" '(org-toggle-narrow-to-subtree :wk "subtree")
    "obnb" '(org-narrow-to-block :wk "block")
    "obne" '(org-narrow-to-element :wk "element")
    "obr" '(org-refile :wk "refile")
    "obs" '(C4/org-trek/body t :wk "search")
    "od" '(:ignore t :wk "date")
    "odd" '(org-deadline :wk "deadline")
    "ods" '(org-schedule :wk "schedule")
    "os" '(:ignore t :wk "special")
    "oss" '(org-edit-special :wk "edit")
    "osx" '(org-edit-src-exit :wk "exit with edits")
    "osX" '(org-edit-src-abort :wk "exit without edits")
    "ose" '(org-babel-execute-src-block :wk "execute")
    "ost" '(org-babel-tangle :wk "tangle"))

  (defhydra C4/org-trek (:timeout 10)
    "A transient mode to logically traverse an Org file."
    ("s" org-babel-next-src-block "next source block")
    ("S" org-babel-previous-src-block "previous source block")
    ("h" org-forward-heading-same-level "next heading at current level")
    ("H" org-backward-heading-same-level "previous heading at current level")
    ("v" org-next-visible-heading "next visible heading")
    ("V" org-previous-visible-heading "previous visible heading")
    ("RET" nil "exit" :exit t))

#+END_SRC

**** Project (=p=)

This domain wraps all commands that affect git project management.

I set it up to navigate projects, find files within my active ones, switch between them, and provide
a powerful git interface for managing them.

The dependencies:

+ projecile: feature rich project management for Emacs
+ magit: probably the last git workflow I'll ever need
+ forge: superior integration with Git forges (GitHub, Gitlab) to manage remote repos

#+BEGIN_SRC emacs-lisp

  (C4/leader-key-def
   "p" '(:ignore t :wk "project")
   "p'" '(projectile-run-vterm :wk "open terminal")
   "pp" '(projectile-switch-project :wk "switch")
   "pf" '(projectile-find-file :wk "find file")
   "pg" '(:ignore t :wk "git")
   "pgg" '(magit-status :wk "status")
   "pgc" '(magit-commit :wk "commit")
   "pgd" '(magit-diff :wk "diff")
   "pgf" '(:ignore t :wk "forge")
   "pgff" '(forge-pull :wk "pull")
   "pgfF" '(forge-fork :wk "fork repo")
   "pgfi" '(forge-list-issues :wk "issues")
   "pgfI" '(forge-create-issue :wk "create issue")
   "pgi" '(magit-init :wk "init")
   "pgp" '(magit-push :wk "push")
   "pgP" '(magit-pull :wk "pull")
   "pgr" '(magit-remote :wk "remote")
   "pgs" '(magit-stage :wk "stage")
   "pgS" '(magit-stage-file :wk "stage file")
   "ps" '(consult-ripgrep :wk "search"))

#+END_SRC

**** Session (=q=)

This domain wraps commands that affect Emacs sessions. It allows quick management of sessions and
workspaces.

#+BEGIN_SRC emacs-lisp

  (C4/leader-key-def
    "q" '(:ignore t :wk "quit")
    "qq" '(save-buffers-kill-emacs :wk "and save")
    "qQ" '(kill-emacs :wk "really quit"))

#+END_SRC

**** Toggle (=t=)

This domain wraps commands that can be toggled. It allows me to switch variants of the main theme on
the fly and scale text. It also triggers writeroom-mode in document major modes.

#+BEGIN_SRC emacs-lisp

  (C4/leader-key-def
    "t" '(:ignore t :wk "toggle")
    "tt" '(C4/theme-switcher/body :wk "theme"))

  (defhydra C4/theme-switcher ()
    "Select a variant from main C4 themes"
    ("l" C4/light "light variant")
    ("d" C4/dark "dark variant")
    ("b" C4/black "black variant")
    ("RET" nil "exit" :exit t))

  (defun C4/light ()
    "Clap on!"
    (interactive)
    (consult-theme 'minimal-light))

  (defun C4/dark ()
    "Dimmer switch!"
    (interactive)
    (consult-theme 'minimal))

  (defun C4/black ()
    "Clap off!"
    (interactive)
    (consult-theme 'minimal-black))
#+END_SRC

**** Window (=w=)

This domain wraps all commands that affect windows.

Windows in Emacs can be split, moved, and closed when not needed.

This marks one of the biggest differences between Vim and Emacs: windows are /views/. Buffers in
Emacs are detached from windows and are not killed when a window closes. They persist in the
background until called into another window.

Their state is preserved.

#+BEGIN_QUOTE
C4 is built to center Emacs as the driver of my entire desktop computing experience. At this point,
Emacs largely /is/ my workstation.

So this domain includes bindings for manipulating X windows served by EXWM.

If you use this configuration and find you don't want or need Emacs to be your window manager, you
can remove the desktop bindings and the environment configuration.

Everything will still work in standalone Emacs instances. If it doesn't, please submit an issue.
#+END_QUOTE

#+BEGIN_SRC emacs-lisp

  (C4/leader-key-def
   "w" '(:ignore t :wk "window")
   "ww" '(other-window :wk "cycle windows")
   "wc" '(delete-window :wk "close")
   "wC" '(delete-other-windows :wk "fill frame")
   "wd" '(:ignore t :wk "desktop")
   "wdf" '(exwm-floating-toggle-floating :wk "floating")
   "wdF" '(exwm-layout-toggle-fullscreen :wk "fullscreen")
   "wdk" '(exwm-layout-toggle-keyboard :wk "keyboard mode")
   "wdm" '(exwm-layout-toggle-mode-line :wk "mode line")
   "wdM" '(exwm-layout-toggle-minibuffer :wk "minibuffer")
   "wn" '(:ignore t :wk "navigator")
   "wnn" '(C4/window-commander/body :wk "interactive")
   "wni" '(windmove-up :wk "jump up")
   "wnI" '(windmove-swap-states-up "swap up")
   "wnk" '(windmove-down :wk "jump down")
   "wnK" '(windmove-swap-states-down :wk "swap down")
   "wnj" '(windmove-left :wk "jump left")
   "wnJ" '(windmove-swap-states-left :wk "swap left")
   "wnl" '(windmove-right :wk "jump right")
   "wnL" '(windmove-swap-states-right :wk "swap right")
   "wnw" '(windmove-display-up :wk "open next window above")
   "wnW" '(windmove-delete-up :wk "close window above")
   "wns" '(windmove-display-down :wk "open next window below")
   "wnS" '(windmove-delete-down :wk "close window below")
   "wna" '(windmove-display-left :wk "open next window left")
   "wnA" '(windmove-delete-left :wk "close window to left")
   "wnd" '(windmove-display-right :wk "open next window right")
   "wnD" '(windmove-delete-right :wk "close window to right")
   "ws" '(:ignore t :wk "split")
   "wss" '(split-window-below :wk "horizontal")
   "wsS" '(split-window-right :wk "vertical"))

  (defhydra C4/window-commander (:timeout 10)
    "Interactive window navigation"
    ("SPC" other-window "cycle")
    ("c" delete-window "close")
    ("C" delete-other-windows "fill frame")
    ("i" windmove-up "jump up")
    ("I" windmove-swap-states-up "swap up")
    ("k" windmove-down "jump down")
    ("K" windmove-swap-states-down "swap down")
    ("j" windmove-left "jump left")
    ("J" windmove-swap-states-left "swap left")
    ("l" windmove-right "jump right")
    ("L" windmove-swap-states-right "swap right")
    ("w" windmove-display-up "open next above")
    ("W" windmove-delete-up "close above")
    ("s" windmove-display-down "open next below")
    ("S" windmove-delete-down "close below")
    ("a" windmove-display-left "open next to left")
    ("A" windmove-delete-left "close left")
    ("d" windmove-display-right "open next to right")
    ("D" windmove-delete-right "close right")
    ("RET" nil "exit" :exit t))

#+END_SRC

* Defaults
* Projects
* Programming Modes
* Document Modes
* Desktop Environment
* Modules
** Base

The =base.el= module sets the /baseline/ experience that C4 is intended to provide without any of its other enhancements. This includes:

+ setting the user
+ setting the theme and modeline
+ setting the typography (code and document)
+ sensible UI enhancements
+ essential UX enhancements

The following block configures the settings for the base module.

#+BEGIN_SRC emacs-lisp

  (c4/user
    :name "Chatman R. Jr"
    :email "crjr.code@protonmail.com")

  (c4/base
    :theme 'minimal-light
    :typography
    (c4/typography
      :code '("Input" 13)
      :document '("Lora" 16)))

#+END_SRC

You can take a closer look at the module's inclusions below.

*** ~c4/user~

This function sets the user identity.

#+BEGIN_SRC emacs-lisp :tangle "./modules/base.el"
(cl-defun c4/user (&key name email)
  "Define user identity."
  (setq user-full-name name
          user-full-email email))

#+END_SRC


*** ~c4/base~

This module is exposed to our =C4.el= to create our settings for the base look and feel and
also some essential functionality. It's composed of the =ui= and =ux= modules that follow below.

#+BEGIN_SRC emacs-lisp :tangle "./modules/base.el"
(cl-defun c4/base (&key theme typography)
  (eval (c4/ui theme typography))
  (c4/ux))
#+END_SRC

Let's have a closer look at those subroutines.

**** ~c4/ui~

Now, we set the base UI. It accepts a theme and typography settings from the submodules
documented below.  It also sets basic options that go a long way toward making the
Emacs UI look halfway decent.

#+BEGIN_SRC emacs-lisp :tangle "./modules/base.el"

(defun c4/ui (theme typography)
  "A module for the base UI."
  (setq-default cursor-type 'bar) ; default cursor as bar
  (setq-default frame-title-format '("%b")) ; window title is the buffer name

  (setq linum-format "%4d ") ; line number format
  (column-number-mode 1)
  (show-paren-mode 1) ; show closing parens by default

  (menu-bar-mode -1) ; disable the menubar
  (scroll-bar-mode -1) ; disable visible scroll bar
  (tool-bar-mode -1) ; disable toolbar
  (tooltip-mode -1) ; disable tooltips
  (set-fringe-mode 8) ; allow some space

  ;; Show line numbers in programming modes
  (add-hook 'prog-mode-hook
            (if (and (fboundp 'display-line-numbers-mode) (display-graphic-p))
                #'display-line-numbers-mode
              #'linum-mode))


  ;; Disable for document and terminal modes
  (dolist (mode '(
      org-mode-hook
      term-mode-hook
      shell-mode-hook
      treemacs-mode-hook
      vterm-mode
      eshell-mode-hook))
    (add-hook mode (lambda () (display-line-numbers-mode 0))))

  ;; Make some icons available
  (use-package all-the-icons)

  (eval (c4/theme theme))
  (eval typography))

#+END_SRC

This is a good time to mention that C4 also contains internal modules for composing
functionality across its main modules. These submodules can be swapped in and out as
needed without issue.

The UI base uses =c4/theme= and =c4/typography= submodules. Which I'll explain now.

***** ~c4/theme~

The theme submodule sets up the mode line with [[https://github.com/Malabarba/smart-mode-line][the smart-mode-line package]]. I know a lot of
configurations swear by the Doom Emacs mode line, but I wanted something lighter.

I only want rich-minority to show minor modes I directly allow, so I set the blacklist to =nil=,
and initialize the whitelist with an empty string.

It also checks and installs a subset of themes based on the prefix of the themes passed in.

C4 prefers the [[https://github.com/anler/minimal-theme][minimal theme]] collection, but you can easily any others you want.

The last thing it does is disable the fringe background for that extra bit of crispness.

#+BEGIN_SRC emacs-lisp :tangle "./modules/base.el"

  (defun c4/theme (theme)
    "A submodule for setting a theme and configuring the modeline."
    (use-package smart-mode-line
      :custom
      (sml/theme 'respectful)
      (sml/no-confirm-load-theme t)
      (sml/name-width 24)
      (sml/mode-width 'full)
      (rm-blacklist nil)
      :config
      (sml/setup)
      (add-to-list 'sml/replacer-regexp-list '("^~/.config/emacs/" ":Emacs:") t)
      (add-to-list 'sml/replacer-regexp-list '("^~/Workbench/" ":Code:") t)
      (add-to-list 'sml/replacer-regexp-list '("^~/Org/" ":Org:") t))

      (use-package minimal-theme)
      (load-theme theme t)

      (set-face-attribute 'fringe nil :background nil))
#+END_SRC


***** ~c4/typography~

This submodule defines typography settings for the UI. It allows you to set the fixed pitch (which
is also the default font) as well as the variable pitch (for Org and other document modes).

#+BEGIN_SRC emacs-lisp :tangle "./modules/base.el"

  (cl-defun c4/typography (&key code document)
    "A module for setting typography."
    (set-face-attribute 'default nil
      :font (format "%s-%s:slant=normal" (car code) (cadr code)))
    (set-face-attribute 'fixed-pitch nil
      :font (format "%s-%s" (car code) (cadr code)))
    (set-face-attribute 'variable-pitch nil
      :font (format "%s-%s" (car document) (cadr document))))

#+END_SRC


**** ~c4/ux~

The base UX module that sets some defaults to prevent Emacs from getting on your nerves before your
really start appreciating it. This includes:

+ inhibiting the startup message
+ beginning with a blank scratch
+ no error beeping
+ sensible autosaving
+ "y" or "n" prompting

  And the packages:

+ [[https://github.com/justbur/emacs-which-key][which-key]]: a necessity for discovering the default and custom keybindings throughout this configuration
+ [[https://github.com/Wilfred/helpful][helpful]]: provides a much more useful help interface
+ [[https://github.com/editorconfig/editorconfig-emacs][editorconfig]] plugin for Emacs: to keep style definitions where they belong
+ [[https://github.com/akermu/emacs-libvterm][vterm]]: a rich terminal so I don't have to leave Emacs for my sysadmin flow

#+BEGIN_SRC emacs-lisp :tangle "./modules/base.el"

(defun c4/ux ()
  "A module for the 'base' UX."
  (setq inhibit-startup-message t) ; inhibit startup message
  (setq initial-scratch-message "") ; no scratch message
  (setq visible-bell t)             ; enable visual bell
  (global-auto-revert-mode t) ; autosave buffer on file change
  (delete-selection-mode 1) ; Selected text will be overwritten on typing
  (fset 'yes-or-no-p 'y-or-n-p) ; convert "yes" or "no" confirms to "y" and "n"

  ;; See a database of all defined keybindings
  (use-package which-key
    :init
    (setq which-key-idle-delay 0.96)
    :config
    (which-key-mode))

  ;; Better help documentation
  (use-package helpful
    :custom
    (counsel-describe-function-function #'helpful-callable)
    (counsel-describe-variable-function #'helpful-variable)
    :bind
    ([remap describe-function] . counsel-describe-function)
    ([remap describe-command] . helpful-command)
    ([remap describe-variable] . counsel-describe-variable)
    ([remap describe-key] . helpful-key))

  ;; Editorconfig
  (use-package editorconfig
    :config
    (editorconfig-mode))

  ;; Better terminal
  (use-package vterm)

  (c4/lookup))

#+END_SRC

***** ~c4/lookup~

The UX base includes a single submodule for defining valuable search and sorting functionality using
the [[https://github.com/abo-abo/swiper][ivy ecosystem]] of packages. These include:

+ swiper: incremental buffer searching
+ ivy itself: better minibuffer completion
+ counsel: provides a richer experience in Emacs interactive prompts
+ [[https://github.com/Yevgnen/ivy-rich][ivy-rich]]: provides more contextual information in the minibuffer
+ [[https://github.com/raxod502/prescient.el][ivy-prescient]]: sorts your commands by usage

#+BEGIN_SRC emacs-lisp :tangle "./modules/base.el"

  (defun c4/lookup ()
    "A module for search and command functionality."
    ;; Minibuffer completion
    (use-package selectrum
      :config
      (selectrum-mode 1))

    ;; Intelligent command sorting with prescient
    (use-package selectrum-prescient
      :after selectrum
      :config
      (selectrum-prescient-mode 1)
      (prescient-persist-mode 1))


    ;; Incremental search
    (use-package ctrlf
      :config
      (ctrlf-mode 1))

    (use-package consult
      :init
      (defun find-fd (&optional dir initial)
        (interactive "P")
        (let ((consult-find-command "fd --color=never --full-path ARG OPTS"))
        (consult-find dir initial)))
     (advice-add #'register-preview :override #'consult-register-window)
     :custom
     (register-preview-delay 0)
     (register-preview-function #'consult-register-window)
     (consult-narrow-key "<"))

    (use-package marginalia
      :after consult
      :init
      (marginalia-mode)
      (advice-add #'marginalia-cycle :after
                  (lambda () (when (bound-and-true-p selectrum-mode)
                               (selectrum-exhibit))))
      (setq marginalia-annotators
       '(marginalia-annotators-heavy marginalia-annotators-light)))

    ;; Minibuffer actions
    (use-package embark)

    (use-package embark-consult
      :after (embark consult)
      :demand t
      :hook
      (embark-collect-mode . embark-consult-preview-minor-mode))

    ;; Partial search queries with orderless
    (use-package orderless
      :init
      (icomplete-mode)
      :custom
      (completion-styles '(orderless))))

  (provide 'base)
#+END_SRC

** Projects

The =projects.el= module configures C4 for my Git/GitHub project workflows.

As with the others, to use it, you'll need to load it.

#+BEGIN_SRC emacs-lisp

(c4/projects
  :path "~/Workbench"
  :username "cr-jr")

#+END_SRC

It's pretty straightforward.

It installs projectile and points it to a =path= to look for projects under version control and then
evaluates the ~c4/git~ submodule with your GitHub =username=.

#+BEGIN_SRC emacs-lisp :tangle "./modules/projects.el"
(cl-defun c4/projects (&key path username)
  (use-package projectile
    :diminish
    :config
    (projectile-mode)
    :custom
    (projectile-project-search-path (list path))
    (projectile-completion-system 'ivy)
    (projectile-switch-project-action #'projectile-dired)
    :bind-keymap
    ("C-c p" . projectile-command-map))

  (use-package counsel-projectile
    :after projectile
    :config
    (counsel-projectile-mode))
  (eval (c4/git username)))

#+END_SRC

It has a single submodule for Git configuration you'll want to have a look at.

*** ~c4/git~

This submodule does the actual work of installing and configuring magit & forge. It also includes
[[https://github.com/dgutov/diff-hl][diff-hl]] so you can see changes to the files in your projects in the fringe.

This will make it easier to determine what changes to commit if you choose to stage hunks with magit
instead of whole files.

#+BEGIN_QUOTE
Be aware that you *will need* a GitHub account along with a personal access token to make any of this work.
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle "./modules/projects.el"

(defun c4/git (user)
  (use-package magit
    :commands (magit magit-status)
    :custom
    (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1))

  (use-package diff-hl
    :after magit
    :hook
    (after-init . global-diff-hl-mode)
    (magit-pre-refresh . diff-hl-magit-pre-refresh)
    (magit-post-refresh . diff-hl-magit-post-refresh))

  (use-package forge
    :after magit
    :custom
    (auth-sources '("~/.authinfo"))
    :config
    (ghub-request "GET" "/user" nil
      :forge 'github
      :host "api.github.com"
      :username user
      :auth 'forge)))

(provide 'projects)
#+END_SRC

** Code

The =code.el= module contains configuration and functionality for your programming needs.

The main module sets up packages for programming modes in general and a rich Emacs Lisp editing
experience besides.

You'll also want to include your desired language modules for your main programming projects.

#+BEGIN_SRC emacs-lisp

(c4/code)

#+END_SRC

*** Setup

This module works by including by setting the initial programming experience in a submodule and then
conditionally loading in rich language functionality.

#+BEGIN_SRC emacs-lisp :tangle "./modules/code.el"
  (defun c4/code ()
    (c4/code-init))

#+END_SRC


**** ~c4/code-init~

This submodule configures the base, essential packages for configuring the programming flow.

The big ones are:

+ [[https://github.com/Fanael/rainbow-delimiters][rainbow-delimiters]]
+ [[https://github.com/company-mode/company-mode][company-mode]]
+ [[https://github.com/flycheck/flycheck][flycheck]]
+ [[https://github.com/emacs-lsp/lsp-mode][lsp-mode]]
+ [[https://github.com/emacs-lsp/lsp-ui][lsp-ui]]

#+BEGIN_SRC emacs-lisp :tangle "./modules/code.el"

(defun c4/code-init ()
  (use-package rainbow-delimiters
    :hook (prog-mode . rainbow-delimiters-mode))

  (use-package company
    :hook (prog-mode . company-mode))

  (use-package company-box
    :hook (company-mode . company-box-mode))

  (use-package flycheck
    :hook (prog-mode . flycheck-mode))

  (use-package lsp-mode
    :hook (prog-mode . lsp-deferred)
    :commands (lsp lsp-deferred))

  (use-package lsp-ui
    :after lsp-mode
    :commands lsp-ui-mode)

  (use-package lsp-ivy
    :after lsp-mode
    :commands lsp-ivy-workspace-symbol))

(provide 'code)
#+END_SRC


*** Languages

** Documents

The =documents.el= module configures settings and functionality for document modes in Emacs. Its
primary focus is [[https://orgmode.org][Org Mode]] and configuring it for technical documentation, note-taking, journaling, and
literate programming.

Make sure you load it in:

#+BEGIN_SRC emacs-lisp

(c4/org :path "~/Org")

#+END_SRC

*** ~c4/org~

This is a top-level module exposed by =documents.el= It wraps all of the submodule Org Mode settings
under a common interface for =C4.el=.

#+BEGIN_SRC emacs-lisp :tangle "./modules/documents.el"
  (cl-defun c4/org (&key path)
    (use-package org
      :init
      (setq org-ellipsis " ↴")
      (setq org-directory path)
      (c4/org-agenda)
      (c4/org-templates)
      (c4/org-babel)
      :config
      (c4/org-theme)
      (advice-add 'org-refile :after 'org-save-all-org-buffers)
      :hook
      (org-mode . c4/org-init)))

#+END_SRC

**** ~c4/org-init~

A submodule that defines the absolute basic settings for Org Mode whenever an Org buffer opens.

By default I want automatically indent content under Org headings, enable variable pitch so I can
use my document font, and ensure my text will wrap at the right line length.

Packages in use:

+ [[https://github.com/joostkremers/visual-fill-column][visual-fill-column]]: wraps visual line mode buffers at a given line length and provides the option
  to center the buffer

#+BEGIN_SRC emacs-lisp :tangle "./modules/documents.el"

(defun c4/org-init ()
  (org-indent-mode 1)
  (variable-pitch-mode 1)
  (visual-line-mode 1)
  (auto-fill-mode 1)

  (use-package visual-fill-column
    :defer t
    :custom
    (visual-fill-column-width 108)
    (visual-fill-column-center-text t)
    :hook (org-mode . visual-fill-column-mode)))

#+END_SRC


**** ~c4/org-theme~

A submodule that performs some UI tweaks for Org buffers. Mainly, it resets certain faces to the
code font and makes the bullets look proper.

Packages in use:

+ [[https://github.com/integral-dw/org-superstar-mode][org-superstar-mode]]: make your Org headings /fancy/

#+BEGIN_SRC emacs-lisp :tangle "./modules/documents.el"

(defun c4/org-theme ()
  (set-face-attribute 'org-block nil
    :foreground nil :inherit 'fixed-pitch)
  (set-face-attribute 'org-block-begin-line nil
    :foreground nil :weight 'normal :inherit 'fixed-pitch)
  (set-face-attribute 'org-document-info-keyword nil
    :foreground nil :weight 'normal :inherit 'fixed-pitch)
  (set-face-attribute 'org-drawer nil
    :foreground nil :weight 'normal :inherit 'fixed-pitch)
  (set-face-attribute 'org-property-value nil
    :foreground nil :weight 'normal :inherit 'fixed-pitch)
  (set-face-attribute 'org-block-end-line nil
    :foreground nil :weight 'normal :inherit 'fixed-pitch)
  (set-face-attribute 'org-checkbox nil :inherit 'fixed-pitch)
  (set-face-attribute 'org-code nil :inherit '(shadow fixed-pitch))
  (set-face-attribute 'org-table nil :inherit '(shadow fixed-pitch))
  (set-face-attribute 'org-verbatim nil :inherit '(shadow fixed-pitch))
  (set-face-attribute 'org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch))
  (set-face-attribute 'org-meta-line nil :inherit '(font-lock-comment-face fixed-pitch))

  (use-package org-superstar
    :after org
    :hook
    (org-mode . org-superstar-mode)
    :custom
    (org-superstar-headline-bullets-list
      '("§" "☙" "჻" " " " " " " " "))))

#+END_SRC


**** ~c4/org-agenda~

This submodule sets up the Org agenda flow for creating task lists and project planning.

#+BEGIN_SRC emacs-lisp :tangle "./modules/documents.el"

(defun c4/org-agenda ()
  (setq org-agenda-start-with-log-mode t)
  (setq org-log-done 'time)
  (setq org-log-into-drawer t)

  (setq org-agenda-files
    '("Tasks.org" "Projects.org"))

  (setq org-todo-keywords
    '((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d!)")
        (sequence
          "BACKLOG(b)" "PLAN(p)" "READY(r)" "ACTIVE(a)" "REVIEW(v)"
          "WAIT(w@/!)" "HOLD(h)" "|" "COMPLETED(c)" "CANC(k@)")))

  (setq org-refile-targets
    '(("Archive.org" :maxlevel . 1)
        ("Tasks.org" :maxlevel . 1)))

  (setq org-tag-alist
    '((:startgroup)
        ("@product" . ?P)
        ("@experiment" . ?E)
        ("@resource" . ?R)
        ("@learning" . ?L)
        ("@teaching" . ?T)
        (:endgroup)
        ("prototyping" . ?p)
        ("developing" . ?d)
        ("documenting" . ?D)
        ("testing" . ?t)
        ("refactoring" . ?r)))

  (setq org-agenda-custom-commands
    '(("d" "Dashboard"
        ((agenda "" ((org-deadline-warning-days 7)))
          (todo "NEXT"
            ((org-agenda-overriding-header "Next Tasks")))))

        ("P" "Products" tags-todo "@product")
        ("E" "Experiments" tags-todo "@experiment")
        ("R" "Resources" tags-todo "@resource")
        ("L" "Learning" tags-todo "@learning")
        ("T" "Teaching" tags-todo "@teaching")

        ("s" "Workflow Status"
          ((todo "WAIT"
            ((org-agenda-overriding-header "Waiting on External")
              (org-agenda-files org-agenda-files)))
          (todo "REVIEW"
            ((org-agenda-overriding-header "Under Review")
              (org-agenda-files org-agenda-files)))
          (todo "PLAN"
            ((org-agenda-overriding-header "Planning")
              (org-agenda-files org-agenda-files)))
          (todo "BACKLOG"
            ((org-agenda-overriding-header "Project Backlog")
              (org-agenda-files org-agenda-files)))
          (todo "READY"
            ((org-agenda-overriding-header "Ready for Work")
              (org-agenda-files org-agenda-files)))
          (todo "ACTIVE"
            ((org-agenda-overriding-header "Active Projects")
              (org-agenda-files org-agenda-files)))
          (todo "COMPLETED"
            ((org-agenda-overriding-header "Completed Projects")
              (org-agenda-files org-agenda-files)))
          (todo "CANC"
            ((org-agenda-overriding-header "Cancelled Projects")
              (org-agenda-files org-agenda-files))))))))

#+END_SRC


**** ~c4/org-templates~

This submodule sets up Org capture templates for scaffolding a new task and other TBD templating
needs.

#+BEGIN_SRC emacs-lisp :tangle "./modules/documents.el"

(defun c4/org-templates ()
  (setq org-capture-templates
    `(("t" "Tasks / Projects")
        ("tt" "Task" entry (file+olp "Tasks.org" "Inbox")
          "* TODO %?\n %U\n %a\n %i" :empty-lines 1))))

#+END_SRC


**** ~c4/org-babel~

This submodule configures source block tangling and execution. It also defines the languages to
allow for a literate programming workflow.

#+BEGIN_SRC emacs-lisp :tangle "./modules/documents.el"

(defun c4/org-babel ()
  (org-babel-do-load-languages
    'org-babel-load-languages
    '((emacs-lisp . t)
      (js . t)))

  (setq org-src-fontify-natively t)
  (setq org-confirm-babel-evaluate nil))


(provide 'documents)
#+END_SRC

** Desktop

As I stated earlier, Emacs is the driver of my desktop computing experience.

Therefore, the final piece in my Emacs configuration is EXWM. Using Emacs as my window manager
brings several advantages:

+ A unified desktop interface
+ Less context switching
+ A window manager as flexible and extensible as Emacs itself
+ Enforced focus on my work environment

I'm aware this approach isn't for everyone, and I wouldn't use it myself if I didn't trust the
stability of Emacs as software. If you have trepidations, you can disable the entire desktop module
and everything else will still work.

#+BEGIN_QUOTE
EXWM only works on Linux systems, though.
#+END_QUOTE

*** Setup

To actually use Emacs as my desktop environment, I need to create a =.xinitrc=.

#+BEGIN_SRC sh :tangle "~/.xinitrc"
# Caps to CTRL
setxkbmap -option ctrl:nocaps

# Disable touchpad
xinput set-prop 12 "Device Enabled" 0

# Default cursor
xsetroot -cursor_name left_ptr

# Xresources
xrdb ~/.Xresources

# Settings
gnome-settings-daemon &

# Autostart programs
dex -a

# Removable media
udiskie &

# Notifications
dunst &

# Start EXWM
exec dbus-launch --exit-with-session emacs -mm --debug-init
#+END_SRC

I also use software (ARandR) to configure my multi-monitor setup.

#+BEGIN_SRC sh :tangle "./desktop/multihead.sh" :tangle-mode (identity #o755)
#!/bin/sh
xrandr --output LVDS --primary --mode 1366x768 --pos 241x1080 --rotate normal --output VGA-0 --off --output HDMI-0 --mode 1920x1080 --pos 0x0 --rotate normal
#+END_SRC

Finally, I need to load in the main desktop package.

#+BEGIN_SRC emacs-lisp

(c4/desktop)
#+END_SRC


*** Configuration

This is the top level module that =desktop.el= exposes. It wraps all the desktop definition
submodules that are documented below.

#+BEGIN_SRC emacs-lisp :tangle "./modules/desktop.el"
    (defun c4/desktop ()
      "A module for my EXWM configuration."
      (use-package exwm
        :if window-system
        :config
        ;; Startup process
        (start-process-shell-command
          "nitrogen" nil "nitrogen --restore")

        (display-time-mode t)

        (setq exwm-workspace-number 6)
        (setq display-time-default-load-average nil)
        (setq exwm-workspace-warp-cursor t)
        (setq focus-follows-mouse t)

        (setq exwm-input-prefix-keys
              '(?\C-x
                ?\C-u
                ?\C-h
                ?\C-\
                ?\M-x
                ?\M-`
                ?\M-&
                ?\M-:
                ?\s-\ ))

        (setq exwm-input-global-keys
              `(([?\s-I] . windmove-swap-states-up)
                ([?\s-i] . windmove-up)
                ([?\s-L] . windmove-swap-states-right)
                ([?\s-l] . windmove-right)
                ([?\s-K] . windmove-swap-states-down)
                ([?\s-K] . windmove-down)
                ([?\s-J] . windmove-swap-states-left)
                ([?\s-j] . windmove-left)
                ([?\s-r] . exwm-reset)
                ([?\s-Q] . kill-emacs)
                ([?\s-q] . exwm-restart)
                ([?\s-W] . exwm-workspace-swap)
                ([?\s-w] . exwm-workspace-switch)
                ([?\s-D] . counsel-linux-app)
                ([?\s-d] . (lambda (cmd)
                              (interactive (list (read-shell-command "$ ")))
                              (start-process-shell-command cmd nil cmd)))
                ,@(mapcar (lambda (i)
                            `(,(kbd (format "s-%d" i)) .
                              (lambda ()
                                (interactive)
                                (exwm-workspace-switch-create ,i))))
                          (number-sequence 0 9))))

        (define-key exwm-mode-map [?\C-q] 'exwm-input-send-next-key)

        ;; Update window class with the buffer name
        (add-hook 'exwm-update-class-hook #'c4/exwm-update-class)

        (require 'exwm-randr)
        (setq exwm-randr-workspace-monitor-plist
              '(0 "LVDS" 2 "LVDS" 4 "LVDS" 1 "HDMI-0" 3 "HDMI-0" 5 "HDMI-0"))
        (start-process-shell-command "xrandr" nil
                                      (concat user-emacs-directory "desktop/multihead.sh"))
        (exwm-randr-enable)

        (require 'exwm-systemtray)
        (setq exwm-systemtray-height 16)
        (exwm-systemtray-enable)

        (exwm-enable))

      ;; EXWM: Desktop Environment
      (use-package desktop-environment
        :after exwm
        :diminish
        :bind
        ("s-l" . windmove-right)
        :config
        (desktop-environment-mode)))

    (defun c4/exwm-update-class ()
      (exwm-workspace-rename-buffer exwm-class-name))

  (provide 'desktop)
#+END_SRC
